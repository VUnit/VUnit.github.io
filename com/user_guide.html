<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="author" title="About these documents" href="../about.html" /><link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="next" title="Verification Components User Guide" href="../verification_components/user_guide.html" /><link rel="prev" title="Run Library User Guide" href="../run/user_guide.html" />

    <link rel="shortcut icon" href="../_static/vunit.ico"/><!-- Generated with Sphinx 7.3.7 and Furo 2024.08.06 -->
        <title>Communication Library User Guide - VUnit documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=354aac6f" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=302659d7" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/fontawesome.min.css" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/solid.min.css" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/brands.min.css" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">VUnit  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="../_static/VUnit_logo.png" alt="Logo"/>
  </div>
  
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../blog/index.html">Blog</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Blog</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../blog/2023_08_26_vhdl_configurations.html">Improved Support for VHDL Configurations and OSVVM</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blog/2023_04_01_vunit_phases.html">VUnit Phases</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blog/2023_03_31_vunit_events.html">VUnit Events</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blog/2022_09_19_vunit_user_conference.html">VUnit User Conference</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blog/2022_09_06_vunit_and_other_frameworks.html">FAQ What is VUnit’s Relation to Other Verification Frameworks?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blog/2020_08_12_continuous_integration_with_vunit_action_in_10_lines_of_code.html">Continuous Integration With VUnit Action in 10 Lines of Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blog/2018_09_22_sigasi_adds_full_vunit_support.html">Sigasi Adds Full VUnit Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blog/2018_07_22_sigasi_deepens_its_commitment_to_the_vunit_testing_framework.html">Sigasi Deepens Its Commitment to the VUnit Testing Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blog/2018_03_22_vunit_community_developed_bfms.html">VUnit Community Developed BFMs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blog/2018_02_12_vunit3.html">VUnit 3.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blog/2017_12_14_vunit_bfms_as_simple_as_emailing.html">VUnit BFMs - as Simple as Emailing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blog/2017_11_23_vunit_matlab_integration.html">VUnit Matlab Integration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blog/2017_11_07_vunit_3_0_while_waiting_for_vhdl_2017.html">VUnit 3.0 - While Waiting for VHDL-2017</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blog/2017_10_31_vunit_3_0_color_logging.html">VUnit 3.0 Color Logging</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blog/2017_09_28_sigasi_adds_support_for_vunit_testing_framework.html">Sigasi Adds Support for VUnit Testing Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blog/2017_06_03_enable_your_simulator_to_handle_complex_top_level_generics.html">Enable Your Simulator to Handle Complex Top-Level Generics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blog/2017_01_12_vunit_getting_started_1_2_3.html">VUnit - Getting Started 1-2-3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blog/2016_11_22_vunit_the_best_value_for_initial_effort_part3.html">VUnit - The Best Value for Initial Effort - Part 3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blog/2016_11_16_vunit_the_best_value_for_initial_effort_part2.html">VUnit - The Best Value for Initial Effort - Part 2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blog/2016_11_15_vunit_the_best_value_for_initial_effort_part1.html">VUnit - The Best Value for Initial Effort - Part 1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blog/2016_08_08_making_osvvm_a_submodule.html">Making OSVVM a Git Submodule</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blog/2016_02_21_improving_vhdl_testbench_design_with_message_passing.html">Improving VHDL Testbench Design with Message Passing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blog/2016_02_01_website_updates.html">Website Updates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blog/2016_01_29_chat_with_vunit_users_and_developers.html">Chat with VUnit Users and Developers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blog/2016_01_26_welcome_to_our_new_website.html">Welcome to Our New Website</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blog/2015_12_15_free_and_open_source_verification_with_vunit_and_ghdl.html">Free and Open Source Verification with VUnit and GHDL</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blog/2015_10_08_who_is_using_UVM.html">Who’s Using UVM (or Not) for FPGA Development, and Why?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../blog/2015_09_24_short_introduction_to_vunit.html">Short Introduction to VUnit</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">About</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../about.html">What is VUnit?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installing.html">Installing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../testimonials/testimonials.html">Testimonials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Guides</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../user_guide.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../id/user_guide.html">Identity Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../logging/user_guide.html">Logging Library User Guide</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../check/user_guide.html">Check Library User Guide</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Check Library User Guide</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../check/check_api.html"><em>check</em> package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../check/checker_pkg.html"><em>checker</em> package</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../run/user_guide.html">Run Library User Guide</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Communication Library User Guide</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../verification_components/user_guide.html">Verification Components User Guide</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of Verification Components User Guide</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../verification_components/memory_model.html">Memory Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../verification_components/vci.html">Bus Master VCI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../verification_components/vci.html#stream-master-vci">Stream Master VCI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../verification_components/vci.html#stream-slave-vci">Stream Slave VCI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../verification_components/vci.html#synchronization-vci">Synchronization VCI</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../data_types/user_guide.html">Data Types User Guide</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of Data Types User Guide</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../data_types/event_user_guide.html">VUnit Events</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data_types/queue.html"><em>queue</em> package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data_types/integer_array.html"><em>integer_array</em> package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data_types/ext_string.html"><em>external string</em> package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data_types/ext_integer_vector.html"><em>external integer vector</em> package</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../cli.html">Command Line Interface</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../py/ui.html">Python Interface</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle navigation of Python Interface</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../py/vunit.html">vunit.ui</a></li>
<li class="toctree-l2"><a class="reference internal" href="../py/opts.html">Compilation Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="../py/opts.html#simulation-options">Simulation Options</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../hdl_libraries.html">HDL Libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Continuous Integration</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../ci/intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ci/script.html">Setup/configuration scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ci/container.html">Containers and/or Virtual Machines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ci/manual.html">Manual setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ci/usecases.html">Practical use cases</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../release_notes.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="https://github.com/VUnit/vunit/blob/master/docs/com/user_guide.rst?plain=true" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div><div class="edit-this-page">
  <a class="muted-link" href="https://github.com/VUnit/vunit/edit/master/docs/com/user_guide.rst" title="Edit this page">
    <svg><use href="#svg-pencil"></use></svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section id="communication-library-user-guide">
<span id="com-user-guide"></span><h1>Communication Library User Guide<a class="headerlink" href="#communication-library-user-guide" title="Link to this heading">¶</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>The VUnit communication library (<code class="docutils literal notranslate"><span class="pre">com</span></code>) provides a high-level communication mechanism
based on the <a class="reference external" href="http://en.wikipedia.org/wiki/Actor_model">actor model</a>.
The actor model is a mathematical model of computation in which
concurrent <em>actors</em> perform all computation. The only way actors can
communicate is by sending messages to each other and the message passing
is based on two important principles:</p>
<ul class="simple">
<li><p>The sending actor only knows the name of the receiving actor. It
doesn’t know the location of the receiver or how a message gets
there.</p></li>
<li><p>Communication is asynchronous. The sender doesn’t know when the
receiver will read the message.</p></li>
</ul>
<p>By extending the basic communication provided by the actor model <code class="docutils literal notranslate"><span class="pre">com</span></code> can also provide
synchronous communication and some more advanced communication patterns.</p>
</section>
<section id="setup">
<h2>Setup<a class="headerlink" href="#setup" title="Link to this heading">¶</a></h2>
<p>Message passing is not a core functionality of unit testing so <code class="docutils literal notranslate"><span class="pre">com</span></code>
is provided as an optional add-on to VUnit. It is compiled to the
<code class="docutils literal notranslate"><span class="pre">vunit_lib</span></code> library with the <code class="docutils literal notranslate"><span class="pre">add_com</span></code> method in your Python script</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">prj</span> <span class="o">=</span> <span class="n">VUnit</span><span class="o">.</span><span class="n">from_argv</span><span class="p">()</span>
<span class="n">prj</span><span class="o">.</span><span class="n">add_vhdl_builtins</span><span class="p">()</span>
<span class="n">prj</span><span class="o">.</span><span class="n">add_com</span><span class="p">()</span>
</pre></div>
</div>
<p>The VHDL functionality is provided to your testbench with the
<code class="docutils literal notranslate"><span class="pre">com_context</span></code>.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="k">library</span><span class="w"> </span><span class="nn">vunit_lib</span><span class="p">;</span>
<span class="n">context</span><span class="w"> </span><span class="n">vunit_lib</span><span class="p">.</span><span class="n">vunit_context</span><span class="p">;</span>
<span class="n">context</span><span class="w"> </span><span class="n">vunit_lib</span><span class="p">.</span><span class="n">com_context</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="basic-message-passing">
<h2>Basic Message Passing<a class="headerlink" href="#basic-message-passing" title="Link to this heading">¶</a></h2>
<section id="sending-and-receiving">
<h3>Sending and Receiving<a class="headerlink" href="#sending-and-receiving" title="Link to this heading">¶</a></h3>
<p>To send a message we must first create an actor for the receiver. This is done with the <code class="docutils literal notranslate"><span class="pre">new_actor</span></code>
function which takes an optional name parameter. If no name is given the actor will be assigned
a name internally on the format <code class="docutils literal notranslate"><span class="pre">_actor_&lt;n&gt;</span></code> where <code class="docutils literal notranslate"><span class="pre">n</span></code> denotes an integer unique to the
actor.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="k">constant</span><span class="w"> </span><span class="n">my_receiver</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">actor_t</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">new_actor</span><span class="p">(</span><span class="s">&quot;my receiver&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Internally an identity (see <a class="reference internal" href="../id/user_guide.html#id-user-guide"><span class="std std-ref">identity package</span></a>) will be created for each actor
and it is also possible to create an actor directly from an identity.</p>
<blockquote>
<div><p>constant my_receiver_id : id_t := get_id(“my receiver”);
constant my_receiver : actor_t := new_actor(my_receiver_id);</p>
</div></blockquote>
<p>To send a message to the receiver the sender must have access to the value of the <code class="docutils literal notranslate"><span class="pre">my_receiver</span></code> constant.
If the receiver made <code class="docutils literal notranslate"><span class="pre">my_receiver</span></code> publically available, for example with a package, it can be accessed
directly. If not, it can be found with the <code class="docutils literal notranslate"><span class="pre">find</span></code> function providing it has been given an explict name.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="k">constant</span><span class="w"> </span><span class="n">found_receiver</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">actor_t</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="s">&quot;my receiver&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="k">constant</span><span class="w"> </span><span class="n">found_receiver</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">actor_t</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">my_receiver_id</span><span class="p">);</span>
</pre></div>
</div>
<p>The next step is to create a message to send and we start by creating an empty message</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">msg</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">new_msg</span><span class="p">;</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">msg</span></code> is a variable of type <code class="docutils literal notranslate"><span class="pre">msg_t</span></code>. Information is added to the message by pushing objects of
different types into it.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">push_string</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;10101010&quot;</span><span class="p">);</span>
<span class="n">push</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">my_integer</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">com</span></code> supports pushing of all native and standardized IEEE types. In case there is no ambiguity you can just
do <code class="docutils literal notranslate"><span class="pre">push</span></code>, otherwise you have to use the more specific alias <code class="docutils literal notranslate"><span class="pre">push_&lt;type&gt;</span></code> as exemplified above.</p>
<p>To send the created message to the receiver you call the <code class="docutils literal notranslate"><span class="pre">send</span></code> procedure</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">send</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">my_receiver</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">send</span></code> is asynchronous and takes no simulation time, only delta cycles. Messages will be stored in the receiver inbox
until the receiver is ready to receive.</p>
<p><code class="docutils literal notranslate"><span class="pre">net</span></code> is a network connecting actors and it is used to signal that an event has occurred, for example that a message
has been sent. The event notifies all connected actors that something has happened which they may be interested in.
For example, the event created when sending a message will wake up all receivers such that they can see if they are the
receiver for the message.</p>
<p>An actor waiting for a message uses the receive procedure</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">receive</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">my_receiver</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">);</span>
</pre></div>
</div>
<p>This procedure returns immediately if there are pending message(s) in the receiver’s inbox or blocks until the first
message arrives. The returned message contains the oldest incoming message and its information can be retrieved using
<code class="docutils literal notranslate"><span class="pre">pop</span></code> functions. The code below will verify that the message has the expected content using the VUnit
<a class="reference internal" href="../check/user_guide.html#equality-check"><span class="std std-ref">check_equal</span></a> procedure.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">check_equal</span><span class="p">(</span><span class="n">pop_string</span><span class="p">(</span><span class="n">msg</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;10101010&quot;</span><span class="p">);</span>
<span class="n">my_integer</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">pop</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
<span class="n">check_equal</span><span class="p">(</span><span class="n">my_integer</span><span class="p">,</span><span class="w"> </span><span class="mi">17</span><span class="p">);</span>
</pre></div>
</div>
<p>Just like <code class="docutils literal notranslate"><span class="pre">push</span></code> there are both <code class="docutils literal notranslate"><span class="pre">pop</span></code> functions and more verbose aliases on the form <code class="docutils literal notranslate"><span class="pre">pop_&lt;type&gt;</span></code>.</p>
<p>Objects are always popped from the message in the same order they were pushed into the message and once all objects
have been popped the message is empty. If you want to keep a message for later you can make a copy before popping.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">msg_copy</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">copy</span><span class="p">(</span><span class="n">original_msg</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="message-types">
<h3>Message Types<a class="headerlink" href="#message-types" title="Link to this heading">¶</a></h3>
<p>In the example above the sender and the receiver exchanged one type of message (a string followed by an integer) but
the normal use case is that a receiver can handle several types of messages. For example, if the receiver is a bus
functional model (BFM) connected to a memory bus it would be able to handle both read and write messages.</p>
<p>Rather than using a regular type as the message type, for example the string <code class="docutils literal notranslate"><span class="pre">&quot;write&quot;</span></code> for a write message, <code class="docutils literal notranslate"><span class="pre">com</span></code>
provides a special message type.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="k">constant</span><span class="w"> </span><span class="n">write_msg</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">msg_type_t</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">new_msg_type</span><span class="p">(</span><span class="s">&quot;write&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&quot;write&quot;</span></code> is just a description of the message type and not a unique identifier. Even if we have two independently
created BFMs, both providing the constant above in their own packages, they would be given different values by the
<code class="docutils literal notranslate"><span class="pre">new_msg_type</span></code> function. This means that we can safely create the different types of write messages without any risk
of mistaking one for the other.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">msg</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">new_msg</span><span class="p">(</span><span class="n">memory_bfm_pkg</span><span class="p">.</span><span class="n">write_msg</span><span class="p">);</span>
<span class="n">push</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">my_unsigned_address</span><span class="p">);</span>
<span class="n">push</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">my_std_logic_vector_data</span><span class="p">);</span>
<span class="n">send</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">memory_bfm_pkg</span><span class="p">.</span><span class="n">actor</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">);</span>
</pre></div>
</div>
<p>The receiver starts by looking at the message type and then handles the message types it recognizes.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="nc">message_handler</span><span class="o">:</span><span class="w"> </span><span class="k">process</span><span class="w"> </span><span class="k">is</span>
<span class="w">  </span><span class="k">variable</span><span class="w"> </span><span class="n">request_msg</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">msg_t</span><span class="p">;</span>
<span class="w">  </span><span class="k">variable</span><span class="w"> </span><span class="n">msg_type</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">msg_type_t</span><span class="p">;</span>
<span class="w">  </span><span class="k">variable</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">(</span><span class="mi">7</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="k">variable</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">7</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="k">variable</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">integer_vector</span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="mi">255</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="k">others</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="k">begin</span>
<span class="w">  </span><span class="n">receive</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">actor</span><span class="p">,</span><span class="w"> </span><span class="n">request_msg</span><span class="p">);</span>
<span class="w">  </span><span class="n">msg_type</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">message_type</span><span class="p">(</span><span class="n">request_msg</span><span class="p">);</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">msg_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">write_msg</span><span class="w"> </span><span class="k">then</span>
<span class="w">    </span><span class="n">address</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">pop</span><span class="p">(</span><span class="n">request_msg</span><span class="p">);</span>
<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">pop</span><span class="p">(</span><span class="n">request_msg</span><span class="p">);</span>
<span class="w">    </span><span class="n">memory</span><span class="p">(</span><span class="n">to_integer</span><span class="p">(</span><span class="n">address</span><span class="p">))</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">to_integer</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="w">  </span><span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span>
<span class="k">end</span><span class="w"> </span><span class="k">process</span><span class="p">;</span>
</pre></div>
</div>
<p>Normally a BFM would never be exposed to a write message aimed for another BFM but under certain cases it can happen.
For example when using the <a class="reference internal" href="#publisher-subscriber"><span class="std std-ref">publisher/subscriber pattern</span></a> described later.
A typical BFM would also provide a write transaction procedure which hides the message passing details (creating
message, pushing data, and sending). That gives an extra level of type safety (and readability).</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">memory_bfm_pkg</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">my_unsigned_address</span><span class="p">,</span><span class="w"> </span><span class="n">my_std_logic_vector_data</span><span class="p">);</span>
</pre></div>
</div>
<p>If you do not expect the receiver to receive messages of a type it can’t handle you can add this else statement</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="k">else</span>
<span class="w">  </span><span class="n">unexpected_msg_type</span><span class="p">(</span><span class="n">msg_type</span><span class="p">);</span>
<span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span>
</pre></div>
</div>
<p>which will cause an unrecognize message to fail the testbench.</p>
</section>
<section id="message-ownership">
<h3>Message Ownership<a class="headerlink" href="#message-ownership" title="Link to this heading">¶</a></h3>
<p>The sender of a message is the owner of that message while it’s being created. As soon as the <code class="docutils literal notranslate"><span class="pre">send</span></code> procedure is
called that ownership is handed over to the receiver and the message passed to the <code class="docutils literal notranslate"><span class="pre">send</span></code> call can no longer be used
to retrieve the information you pushed into it. If you need to keep the message information you can make a copy
before calling <code class="docutils literal notranslate"><span class="pre">send</span></code>.</p>
<p>Since memory is allocated whenever you push to a message its important
that the receiver side deallocates that memory to avoid memory leaks. This can be done explicitly by deleting the
message.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">delete</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
</pre></div>
</div>
<p>However, the typical receiver is a looping process that calls the <code class="docutils literal notranslate"><span class="pre">receive</span></code> procedure as soon as the previous message
has been handled. To simplify the design of the such a receiver the <code class="docutils literal notranslate"><span class="pre">delete</span></code> procedure is called first in the
<code class="docutils literal notranslate"><span class="pre">receive</span></code> procedure to delete the message from the previous loop iteration.</p>
</section>
<section id="replying-to-a-message">
<h3>Replying to a Message<a class="headerlink" href="#replying-to-a-message" title="Link to this heading">¶</a></h3>
<p>Replying to a message is done with the <code class="docutils literal notranslate"><span class="pre">reply</span></code> procedure. Below is the previous message handler process which has
been updated to also handle read request messages. Every such message results in a reply message targeting the
requesting actor.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="nc">message_handler</span><span class="o">:</span><span class="w"> </span><span class="k">process</span><span class="w"> </span><span class="k">is</span>
<span class="w">  </span><span class="k">variable</span><span class="w"> </span><span class="n">request_msg</span><span class="p">,</span><span class="w"> </span><span class="n">reply_msg</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">msg_t</span><span class="p">;</span>
<span class="w">  </span><span class="k">variable</span><span class="w"> </span><span class="n">msg_type</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">msg_type_t</span><span class="p">;</span>
<span class="w">  </span><span class="k">variable</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">(</span><span class="mi">7</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="k">variable</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">7</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="k">variable</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">integer_vector</span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="mi">255</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="p">(</span><span class="k">others</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="k">begin</span>
<span class="w">  </span><span class="n">receive</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">actor</span><span class="p">,</span><span class="w"> </span><span class="n">request_msg</span><span class="p">);</span>
<span class="w">  </span><span class="n">msg_type</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">message_type</span><span class="p">(</span><span class="n">request_msg</span><span class="p">);</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">msg_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">write_msg</span><span class="w"> </span><span class="k">then</span>
<span class="w">    </span><span class="n">address</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">pop</span><span class="p">(</span><span class="n">request_msg</span><span class="p">);</span>
<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">pop</span><span class="p">(</span><span class="n">request_msg</span><span class="p">);</span>
<span class="w">    </span><span class="n">memory</span><span class="p">(</span><span class="n">to_integer</span><span class="p">(</span><span class="n">address</span><span class="p">))</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">to_integer</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

<span class="w">  </span><span class="k">elsif</span><span class="w"> </span><span class="n">msg_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read_msg</span><span class="w"> </span><span class="k">then</span>
<span class="w">    </span><span class="n">address</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">pop</span><span class="p">(</span><span class="n">request_msg</span><span class="p">);</span>
<span class="w">    </span><span class="n">data</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">to_std_logic_vector</span><span class="p">(</span><span class="n">memory</span><span class="p">(</span><span class="n">to_integer</span><span class="p">(</span><span class="n">address</span><span class="p">)),</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>
<span class="w">    </span><span class="n">reply_msg</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">new_msg</span><span class="p">(</span><span class="n">read_reply_msg</span><span class="p">);</span>
<span class="w">    </span><span class="n">push</span><span class="p">(</span><span class="n">reply_msg</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>
<span class="w">    </span><span class="n">reply</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">request_msg</span><span class="p">,</span><span class="w"> </span><span class="n">reply_msg</span><span class="p">);</span>

<span class="w">  </span><span class="k">else</span>
<span class="w">    </span><span class="n">unexpected_msg_type</span><span class="p">(</span><span class="n">msg_type</span><span class="p">);</span>
<span class="w">  </span><span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span>
<span class="k">end</span><span class="w"> </span><span class="k">process</span><span class="p">;</span>
</pre></div>
</div>
<p>Just like the <code class="docutils literal notranslate"><span class="pre">send</span></code> procedure <code class="docutils literal notranslate"><span class="pre">reply</span></code> will hand message ownership to the receiver.</p>
</section>
<section id="receiving-a-reply">
<h3>Receiving a Reply<a class="headerlink" href="#receiving-a-reply" title="Link to this heading">¶</a></h3>
<p>If you want to await a specific message like the reply to a request message you can use the <code class="docutils literal notranslate"><span class="pre">receive_reply</span></code>
procedure. Below is a read procedure for our memory BFM.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="k">procedure</span><span class="w"> </span><span class="n">read</span><span class="p">(</span>
<span class="w">  </span><span class="k">signal</span><span class="w"> </span><span class="n">net</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">inout</span><span class="w"> </span><span class="n">event_t</span><span class="p">;</span>
<span class="w">  </span><span class="k">constant</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">(</span><span class="mi">7</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="k">variable</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">std_logic_vector</span><span class="p">(</span><span class="mi">7</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="k">is</span>
<span class="w">  </span><span class="k">variable</span><span class="w"> </span><span class="n">request_msg</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">msg_t</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">new_msg</span><span class="p">(</span><span class="n">read_msg</span><span class="p">);</span>
<span class="w">  </span><span class="k">variable</span><span class="w"> </span><span class="n">reply_msg</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">msg_t</span><span class="p">;</span>
<span class="w">  </span><span class="k">variable</span><span class="w"> </span><span class="n">msg_type</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">msg_type_t</span><span class="p">;</span>
<span class="k">begin</span>
<span class="w">  </span><span class="n">push</span><span class="p">(</span><span class="n">request_msg</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="p">);</span>
<span class="w">  </span><span class="n">send</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">actor</span><span class="p">,</span><span class="w"> </span><span class="n">request_msg</span><span class="p">);</span>
<span class="w">  </span><span class="n">receive_reply</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">request_msg</span><span class="p">,</span><span class="w"> </span><span class="n">reply_msg</span><span class="p">);</span>
<span class="w">  </span><span class="n">msg_type</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">message_type</span><span class="p">(</span><span class="n">reply_msg</span><span class="p">);</span>
<span class="w">  </span><span class="n">data</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">pop</span><span class="p">(</span><span class="n">reply_msg</span><span class="p">);</span>
<span class="k">end</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">receive_reply</span></code> will block until the specified message is received. All other incoming messages will be ignored but
can be retrieved later. Note that we didn’t need a message type for the reply messages, the read procedure just
throws it away. However, we will see later that including it can be helpful when debugging a communication system.</p>
<p>Sending a request and directly receiving the reply is a common sequence of calls so it has been given a dedicated
<code class="docutils literal notranslate"><span class="pre">request</span></code> procedure. The two lines above can be replaced by</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">request</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">actor</span><span class="p">,</span><span class="w"> </span><span class="n">request_msg</span><span class="p">,</span><span class="w"> </span><span class="n">reply_msg</span><span class="p">);</span>
</pre></div>
</div>
<p>Another approach to the read procedure is to think of it as two steps. The first step sends the the non-blocking read
request and the second waits to get the requested data. The link between the two is the request message. This message
is sometimes called a future since it represents the requested data that will be available in the future. Splitting
blocking procedures like this allow you to initiate several concurrent transactions on different DUT interfaces or
perform other tasks while waiting for the replies.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">memory_bfm_pkg</span><span class="p">.</span><span class="n">non_blocking_read</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mh">x&quot;80&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">future</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">future1</span><span class="p">);</span>
<span class="n">some_other_bfm_pkg</span><span class="p">.</span><span class="n">non_blocking_transaction</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">some_input_parameters</span><span class="p">,</span><span class="w"> </span><span class="n">future2</span><span class="p">);</span>

<span class="o">&lt;</span><span class="n">Do</span><span class="w"> </span><span class="n">other</span><span class="w"> </span><span class="n">things</span><span class="o">&gt;</span>

<span class="n">memory_bfm_pkg</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">future1</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>
<span class="n">some_other_bfm_pkg</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">future2</span><span class="p">,</span><span class="w"> </span><span class="n">requested_information</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="signing-messages">
<h3>Signing Messages<a class="headerlink" href="#signing-messages" title="Link to this heading">¶</a></h3>
<p>So far all request messages have been anonymous, I’ve only created an actor for the receiving part. In these situations
the receiver <code class="docutils literal notranslate"><span class="pre">reply</span></code> call can’t send a reply back to the sender so the reply message is placed in the receiver
outbox. The <code class="docutils literal notranslate"><span class="pre">receive_reply</span></code> procedure called by the sender knows that the request message was anonymous and waits
for the reply to appear in the receiver outbox instead of its own inbox.</p>
<p>Some communication patterns, for example the publisher/subscriber pattern, requires that all messages
are signed. To sign a message you can provide the sending actor when the message is created.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">msg</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">new_msg</span><span class="p">(</span><span class="n">sender</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">sending_actor</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="sending-receiving-to-from-multiple-actors">
<h3>Sending/Receiving to/from Multiple Actors<a class="headerlink" href="#sending-receiving-to-from-multiple-actors" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">message_handler</span></code> process presented above had a single actor. However, the actor model is not limited to have one
actor for each concurrently running process. A process may have several actors, each representing some other object
like a channel. A typical receiver in such a design needs to act on messages from several actors and to support that
you can call <code class="docutils literal notranslate"><span class="pre">receive</span></code> with an array of actors rather than a single actor. If several actors have messages the
procedure will return the oldest message from the leftmost actor with a non-empty inbox.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">receive</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">actor_vec_t</span><span class="p">&#39;(</span><span class="n">channel_1</span><span class="p">,</span><span class="w"> </span><span class="n">channel_2</span><span class="p">),</span><span class="w"> </span><span class="n">msg</span><span class="p">);</span>
</pre></div>
</div>
<p>It’s also possible to send a message to multiple receiving actors. Just call <code class="docutils literal notranslate"><span class="pre">send</span></code> with an array of receivers.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">send</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">actor_vec_t</span><span class="p">&#39;(</span><span class="n">receiver_1</span><span class="p">,</span><span class="w"> </span><span class="n">receiver_2</span><span class="p">),</span><span class="w"> </span><span class="n">msg</span><span class="p">);</span>
</pre></div>
</div>
<p>There is no shared ownership of <code class="docutils literal notranslate"><span class="pre">msg</span></code> once it’s sent. The sender loses ownership and each receiver get its own
copy.</p>
</section>
</section>
<section id="synchronous-communication">
<h2>Synchronous Communication<a class="headerlink" href="#synchronous-communication" title="Link to this heading">¶</a></h2>
<p>Message passing based on the actor model is inherently asynchronous in nature. Sending a message takes no time which
means that the sender can send any number of messages before the receiver starts processing the first one. Transactions
requesting a reply, like the read transaction presented before, will naturally break this flow of unprocessed messages
by blocking while waiting for a reply. Sometimes it’s also useful to synchronize the sender and receiver on
transactions which initiate an action without expecting a reply, a write transaction for example. To do that we can
create a reply message with a positive or negative acknowledge to signal the completion of the transaction or the
failure to complete the request. Rather than doing that explicitly you can use one of the convenience procedures that
<code class="docutils literal notranslate"><span class="pre">com</span></code> provides.</p>
<p>Instead of using the <code class="docutils literal notranslate"><span class="pre">reply</span></code> procedure with a reply message the receiver can use <code class="docutils literal notranslate"><span class="pre">acknowledge</span></code> with a
positive/negative response in the form of true/false boolean as the third parameter</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">acknowledge</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">request_msg</span><span class="p">,</span><span class="w"> </span><span class="n">positive_ack</span><span class="p">);</span>
</pre></div>
</div>
<p>On the sender side there is a matching <code class="docutils literal notranslate"><span class="pre">receive_reply</span></code> procedure that will return that boolean.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">receive_reply</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">positive_ack</span><span class="p">);</span>
</pre></div>
</div>
<p>There is also a <code class="docutils literal notranslate"><span class="pre">request</span></code> procedure to be used in conjunction with <code class="docutils literal notranslate"><span class="pre">acknowledge</span></code>.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">request</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">actor</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">positive_ack</span><span class="p">);</span>
</pre></div>
</div>
<p>Another approach to synchronization is to limit the number of unprocessed messages that a
receiver can have in its inbox. If the limit is reached, a new send to that receiver will block.
The default inbox size is <code class="docutils literal notranslate"><span class="pre">integer'high</span></code> but it can be set to some other value when the actor is created.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="k">constant</span><span class="w"> </span><span class="n">my_actor</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">actor_t</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">new_actor</span><span class="p">(</span><span class="s">&quot;my actor&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">inbox_size</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>It’s also possible to resize the inbox of an already created actor.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">resize</span><span class="p">(</span><span class="n">my_actor</span><span class="p">,</span><span class="w"> </span><span class="n">new_size</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>Reducing the size below the number of messages in the inbox will cause a run-time failure.</p>
<p>A third way to synchronize actors is to have a dedicated message for that purpose but without any information exchange.
The message exchange will just be an indication that the receiver is idling waiting for new messages.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">request_msg</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">new_msg</span><span class="p">(</span><span class="n">wait_until_idle_msg</span><span class="p">);</span>
<span class="n">request</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">actor_to_synchronize</span><span class="p">,</span><span class="w"> </span><span class="n">request_msg</span><span class="p">,</span><span class="w"> </span><span class="n">reply_msg</span><span class="p">);</span>
</pre></div>
</div>
<p>The sender will block on the <code class="docutils literal notranslate"><span class="pre">request</span></code> call until the actor to synchronize has replied and the two actors becomes
synchronized. Since there is no information exchange there is no need to pop the reply message.</p>
<p>The actor to synchronize will have to add an if statement branch to handle the new message type. Below I’ve extended
the message handling of the previous BFM example.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">receive</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">actor</span><span class="p">,</span><span class="w"> </span><span class="n">request_msg</span><span class="p">);</span>
<span class="n">msg_type</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">message_type</span><span class="p">(</span><span class="n">request_msg</span><span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="n">msg_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wait_until_idle_msg</span><span class="w"> </span><span class="k">then</span>
<span class="w">  </span><span class="n">reply_msg</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">new_msg</span><span class="p">;</span>
<span class="w">  </span><span class="n">reply</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">request_msg</span><span class="p">,</span><span class="w"> </span><span class="n">reply_msg</span><span class="p">);</span>
<span class="k">elsif</span><span class="w"> </span><span class="n">msg_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">write_msg</span><span class="w"> </span><span class="k">then</span>

<span class="w">  </span><span class="p">...</span>

<span class="k">else</span>
<span class="w">  </span><span class="n">unexpected_msg_type</span><span class="p">(</span><span class="n">msg_type</span><span class="p">);</span>
<span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that no information is pushed to the reply message in this example but you may want to have a message type for
debugging purposes.</p>
</section>
<section id="message-handlers-and-verification-component-interfaces-vci">
<h2>Message Handlers and Verification Component Interfaces (VCI)<a class="headerlink" href="#message-handlers-and-verification-component-interfaces-vci" title="Link to this heading">¶</a></h2>
<p>The synchronization based on <code class="docutils literal notranslate"><span class="pre">wait_until_idle_msg</span></code> is something that can be used by many actors. We’ve seen before
how we can create transaction procedures like <code class="docutils literal notranslate"><span class="pre">read</span></code> and <code class="docutils literal notranslate"><span class="pre">write</span></code> and we can also create such a procedure for this
message. To synchronize with the memory BFM actor we would just do</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">wait_until_idle</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">memory_bfm_pkg</span><span class="p">.</span><span class="n">actor</span><span class="p">);</span>
</pre></div>
</div>
<p>We can also create a reusable procedure for the message handling.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="k">procedure</span><span class="w"> </span><span class="n">handle_wait_until_idle</span><span class="p">(</span>
<span class="w">  </span><span class="k">signal</span><span class="w"> </span><span class="n">net</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">inout</span><span class="w"> </span><span class="n">event_t</span><span class="p">;</span>
<span class="w">  </span><span class="k">variable</span><span class="w"> </span><span class="n">msg_type</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">inout</span><span class="w"> </span><span class="n">msg_type_t</span><span class="p">;</span>
<span class="w">  </span><span class="k">variable</span><span class="w"> </span><span class="n">request_msg</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">inout</span><span class="w"> </span><span class="n">msg_t</span><span class="p">)</span><span class="w"> </span><span class="k">is</span>
<span class="w">  </span><span class="k">variable</span><span class="w"> </span><span class="n">reply_msg</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">msg_t</span><span class="p">;</span>
<span class="k">begin</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">msg_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wait_until_idle_msg</span><span class="w"> </span><span class="k">then</span>
<span class="w">    </span><span class="n">handle_message</span><span class="p">(</span><span class="n">msg_type</span><span class="p">);</span>
<span class="w">    </span><span class="n">reply_msg</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">new_msg</span><span class="p">;</span>
<span class="w">    </span><span class="n">reply</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">request_msg</span><span class="p">,</span><span class="w"> </span><span class="n">reply_msg</span><span class="p">);</span>
<span class="w">  </span><span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span>
<span class="k">end</span><span class="p">;</span>
</pre></div>
</div>
<p>This is the same code I showed before to handle the wait until idle message with one addition - the call to the
<code class="docutils literal notranslate"><span class="pre">handle_message</span></code> procedure. <code class="docutils literal notranslate"><span class="pre">handle_message</span></code> is in itself a message handler, the simplest message handler possible.
The only thing it does is to set <code class="docutils literal notranslate"><span class="pre">msg_type</span></code> to a special value <code class="docutils literal notranslate"><span class="pre">message_handled</span></code>. To understand why we can look at
the updated BFM.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">receive</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">actor</span><span class="p">,</span><span class="w"> </span><span class="n">request_msg</span><span class="p">);</span>
<span class="n">msg_type</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">message_type</span><span class="p">(</span><span class="n">request_msg</span><span class="p">);</span>

<span class="n">handle_wait_until_idle</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">msg_type</span><span class="p">,</span><span class="w"> </span><span class="n">request_msg</span><span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="n">msg_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">write_msg</span><span class="w"> </span><span class="k">then</span>

<span class="w">  </span><span class="p">...</span>

<span class="k">else</span>
<span class="w">  </span><span class="n">unexpected_msg_type</span><span class="p">(</span><span class="n">msg_type</span><span class="p">);</span>
<span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span>
</pre></div>
</div>
<p>After <code class="docutils literal notranslate"><span class="pre">handle_wait_until_idle</span></code> returns, <code class="docutils literal notranslate"><span class="pre">msg_type</span></code> has the value <code class="docutils literal notranslate"><span class="pre">message_handled</span></code> and no more message handling
takes place in the following if statement. The <code class="docutils literal notranslate"><span class="pre">unexpected_msg_type</span></code> procedure of the else branch will be called but
that procedure takes no action when the message type is <code class="docutils literal notranslate"><span class="pre">message_handled</span></code>.</p>
<p>By putting the <code class="docutils literal notranslate"><span class="pre">wait_until_idle_msg</span></code> message type and the <code class="docutils literal notranslate"><span class="pre">wait_until_idle</span></code> and <code class="docutils literal notranslate"><span class="pre">handle_wait_until_idle</span></code>
procedures in a package we can create a reusable verification component interface (VCI) that can be added to actors.
An actor can call several message handlers, that is add several interfaces, and you can create message handlers that
call other message handlers to bundle interfaces. The interface I just presented is actually already provided as a part
of VUnit’s <a class="reference internal" href="../verification_components/vci.html#sync-vci"><span class="std std-ref">synchronization VCI</span></a>.</p>
<section id="timeout">
<h3>Timeout<a class="headerlink" href="#timeout" title="Link to this heading">¶</a></h3>
<p>Receive and send procedures which may block on empty or full inboxes have an optional timeout parameter. For example</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">receive</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">actor</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">timeout</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="n">ns</span><span class="p">);</span>
</pre></div>
</div>
<p>Reaching the timeout limit is an error that will fail the testbench. If you need to timeout a receive call without
failing you can use the <code class="docutils literal notranslate"><span class="pre">wait_for_message</span></code>, <code class="docutils literal notranslate"><span class="pre">has_message</span></code>, and <code class="docutils literal notranslate"><span class="pre">get_message</span></code> subprograms. The <code class="docutils literal notranslate"><span class="pre">status</span></code> returned
by the <code class="docutils literal notranslate"><span class="pre">wait_for_message</span></code> procedure below will be <code class="docutils literal notranslate"><span class="pre">ok</span></code> if a message is received before the timeout and <code class="docutils literal notranslate"><span class="pre">timeout</span></code>
if the timeout limit is reached.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">wait_for_message</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">my_actor</span><span class="p">,</span><span class="w"> </span><span class="n">status</span><span class="p">,</span><span class="w"> </span><span class="n">timeout</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="n">ns</span><span class="p">);</span>
</pre></div>
</div>
<p>You can also see if an actor has at least one message in its inbox.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">has_message</span><span class="p">(</span><span class="n">my_actor</span><span class="p">);</span>
</pre></div>
</div>
<p>When there are messages in the inbox you can get the oldest with</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">get_message</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">my_actor</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">);</span>
</pre></div>
</div>
<p>It’s also possible to wait for a reply with a timeout.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">wait_for_reply</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">request_msg</span><span class="p">,</span><span class="w"> </span><span class="n">status</span><span class="p">,</span><span class="w"> </span><span class="n">timeout</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="n">ns</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ok</span><span class="w"> </span><span class="k">then</span>
<span class="w">  </span><span class="n">get_reply</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">request_msg</span><span class="p">,</span><span class="w"> </span><span class="n">reply_msg</span><span class="p">);</span>
<span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="deferred-actor-creation">
<h3>Deferred Actor Creation<a class="headerlink" href="#deferred-actor-creation" title="Link to this heading">¶</a></h3>
<p>When finding an actor using the <code class="docutils literal notranslate"><span class="pre">find</span></code> function there is a potential race condition. What if the actor hasn’t been
created yet? The default VUnit solution is that the <code class="docutils literal notranslate"><span class="pre">find</span></code> function creates a temporary actor with limited
functionality and defer proper actor creation until the <code class="docutils literal notranslate"><span class="pre">new_actor</span></code> function is called. The process calling <code class="docutils literal notranslate"><span class="pre">find</span></code>
can send messages to this actor and can’t tell the difference. However, it’s not possible to call receive type of
procedures on such an actor. Full actor capabilities are acquired when the receiver process has created the actor with
<code class="docutils literal notranslate"><span class="pre">new_actor</span></code>.</p>
<p>The danger with this approach is if the actor “found” by the sender is never created, maybe as a result of a misspelled
name. In that case the sender will send messages that are never received but it will block on the second send since the
temporary actor has an inbox of size one. The safest way to avoid this is to not use <code class="docutils literal notranslate"><span class="pre">find</span></code> but rather make the actor
constant available to the sender. It’s also possible to to disable the deferred creation by adding an extra parameter
to the <code class="docutils literal notranslate"><span class="pre">find</span></code> call</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">find</span><span class="p">(</span><span class="s">&quot;actor name&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">enable_deferred_creation</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">false</span><span class="p">);</span>
</pre></div>
</div>
<p>If the actor isn’t found the function returns <code class="docutils literal notranslate"><span class="pre">null_actor</span></code> so to make this work you must make sure that the
<code class="docutils literal notranslate"><span class="pre">find</span></code> function is called after <code class="docutils literal notranslate"><span class="pre">new_actor</span></code>, for example by adding an initial delay before making the call.</p>
<p>Another approach is to make sure that there are no deferred creations pending a short delay into the simulation, before
the actual testing starts. You can find out by calling the <code class="docutils literal notranslate"><span class="pre">num_of_deferred_creations</span></code> function.</p>
</section>
</section>
<section id="publisher-subscriber-pattern">
<span id="publisher-subscriber"></span><h2>Publisher/Subscriber Pattern<a class="headerlink" href="#publisher-subscriber-pattern" title="Link to this heading">¶</a></h2>
<p>A common message pattern is the publisher/subscriber pattern where a publisher actor publishes a message rather than
sending it. Actors interested in these messages subscribe to the publisher and the published messages are received just
like messages sent directly to the subscribers. The purpose of this pattern is to decouple the publisher from the
subscribers, it doesn’t have to know who the subscribers are and there is no need to update the publisher when
subscribers are added or removed.</p>
<p>An example for how this pattern can be used is when you have a verification component monitoring an interface of the
DUT. Let’s say we have a simple adder with streaming input and output interfaces. The input interface consists of two
unsigned operands and a data valid signal while the output consists of an unsigned <code class="docutils literal notranslate"><span class="pre">sum</span></code> and a data valid. The input
interface is controlled by a driver BFM which receives <code class="docutils literal notranslate"><span class="pre">add</span></code> transactions as well as <code class="docutils literal notranslate"><span class="pre">wait_for_time</span></code> to insert idle
cycles in the input stream. <code class="docutils literal notranslate"><span class="pre">wait_for_time</span></code> is a standard VCI provided by the <a class="reference internal" href="../verification_components/vci.html#sync-vci"><span class="std std-ref">sync_pkg</span></a>. The output
interface has a monitor process which creates sum messages from valid output sums. Just like the input driver doesn’t
know or care who’s sending the add transactions, the monitor doesn’t have to know who’s consuming the sum messages. To
achieve that it will publish the sum messages and just provide the publishing actor (<code class="docutils literal notranslate"><span class="pre">monitor</span></code>).</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">monitor_process</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">process</span><span class="w"> </span><span class="k">is</span>
<span class="w">  </span><span class="k">variable</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">msg_t</span><span class="p">;</span>
<span class="k">begin</span>
<span class="w">  </span><span class="k">wait</span><span class="w"> </span><span class="k">until</span><span class="w"> </span><span class="n">rising_edge</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="n">dv_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="p">);</span>
<span class="w">  </span><span class="n">msg</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">new_msg</span><span class="p">(</span><span class="n">sum_msg</span><span class="p">);</span>
<span class="w">  </span><span class="n">push</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">to_integer</span><span class="p">(</span><span class="n">sum</span><span class="p">));</span>
<span class="w">  </span><span class="n">publish</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">monitor</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">);</span>
<span class="k">end</span><span class="w"> </span><span class="k">process</span><span class="p">;</span>
</pre></div>
</div>
<p>In addition to the driver and the monitor there is a scoreboard process to verify the adder functionality. The
scoreboard subscribes to the sum messages published by the monitor using the <code class="docutils literal notranslate"><span class="pre">subscribe</span></code> procedure. Rather than
having a single actor the scoreboard has several actors called channels and the <code class="docutils literal notranslate"><span class="pre">slave_channel</span></code> is setup to subscribe
to messages published by the <code class="docutils literal notranslate"><span class="pre">monitor</span></code> actor.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">subscribe</span><span class="p">(</span><span class="n">slave_channel</span><span class="p">,</span><span class="w"> </span><span class="n">monitor</span><span class="p">);</span>
</pre></div>
</div>
<p>The next step is to make sure that the scoreboard also receives the add transactions on the input interface. There are
several ways to do this. One is to build another monitor for the input interface and another is to let the driver
publish the add transactions. However, in order to demonstrate <code class="docutils literal notranslate"><span class="pre">com</span></code> functionality this scoreboard will use a third
approach and let the scoreboard subscribe to inbound traffic to the driver. This can be done by adding a third
parameter to the <code class="docutils literal notranslate"><span class="pre">subscribe</span></code> call.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">subscribe</span><span class="p">(</span><span class="n">master_channel</span><span class="p">,</span><span class="w"> </span><span class="n">driver</span><span class="p">,</span><span class="w"> </span><span class="n">inbound</span><span class="p">);</span>
</pre></div>
</div>
<p>The default value used before is <code class="docutils literal notranslate"><span class="pre">published</span></code> and it is also possible to subscribe to <code class="docutils literal notranslate"><span class="pre">outbound</span></code> traffic.
<code class="docutils literal notranslate"><span class="pre">outbound</span></code> traffic is every output message from an actor regardless if that message is the result of a <code class="docutils literal notranslate"><span class="pre">publish</span></code>,
<code class="docutils literal notranslate"><span class="pre">send</span></code>, or <code class="docutils literal notranslate"><span class="pre">reply</span></code> call.</p>
<p>With the two subscriptions at hand we can create a scoreboard process. The main flow of the code below is to wait for
an <code class="docutils literal notranslate"><span class="pre">add_msg</span></code> on the <code class="docutils literal notranslate"><span class="pre">master_channel</span></code> (<code class="docutils literal notranslate"><span class="pre">wait_for_time</span></code> is ignored) and when it’s received wait for the associated
<code class="docutils literal notranslate"><span class="pre">sum_msg</span></code> on the <code class="docutils literal notranslate"><span class="pre">slave_channel</span></code>. Once both these messages are available the scoreboard will use its reference
model to verify that the output data matches the input.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">scoreboard_process</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">process</span><span class="w"> </span><span class="k">is</span>
<span class="w">  </span><span class="k">variable</span><span class="w"> </span><span class="n">master_msg</span><span class="p">,</span><span class="w"> </span><span class="n">slave_msg</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">msg_t</span><span class="p">;</span>
<span class="w">  </span><span class="k">variable</span><span class="w"> </span><span class="n">msg_type</span><span class="w">         </span><span class="o">:</span><span class="w"> </span><span class="n">msg_type_t</span><span class="p">;</span>

<span class="w">  </span><span class="k">procedure</span><span class="w"> </span><span class="n">do_model_check</span><span class="p">(</span><span class="n">indata</span><span class="p">,</span><span class="w"> </span><span class="n">outdata</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">msg_t</span><span class="p">)</span><span class="w"> </span><span class="k">is</span>
<span class="w">    </span><span class="k">variable</span><span class="w"> </span><span class="n">op_a</span><span class="p">,</span><span class="w"> </span><span class="n">op_b</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">natural</span><span class="p">;</span>
<span class="w">  </span><span class="k">begin</span>
<span class="w">    </span><span class="n">op_a</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">pop</span><span class="p">(</span><span class="n">indata</span><span class="p">);</span>
<span class="w">    </span><span class="n">op_b</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">pop</span><span class="p">(</span><span class="n">indata</span><span class="p">);</span>
<span class="w">    </span><span class="n">sum</span><span class="w">  </span><span class="o">:=</span><span class="w"> </span><span class="n">pop</span><span class="p">(</span><span class="n">outdata</span><span class="p">);</span>
<span class="w">    </span><span class="n">check_equal</span><span class="p">(</span><span class="n">sum</span><span class="p">,</span><span class="w"> </span><span class="n">op_a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">op_b</span><span class="p">);</span>
<span class="w">  </span><span class="k">end</span><span class="p">;</span>
<span class="k">begin</span>
<span class="w">  </span><span class="n">subscribe</span><span class="p">(</span><span class="n">master_channel</span><span class="p">,</span><span class="w"> </span><span class="n">driver</span><span class="p">,</span><span class="w"> </span><span class="n">inbound</span><span class="p">);</span>
<span class="w">  </span><span class="n">subscribe</span><span class="p">(</span><span class="n">slave_channel</span><span class="p">,</span><span class="w"> </span><span class="n">monitor</span><span class="p">);</span>
<span class="w">  </span><span class="k">loop</span>
<span class="w">    </span><span class="n">receive</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">master_channel</span><span class="p">,</span><span class="w"> </span><span class="n">master_msg</span><span class="p">);</span>
<span class="w">    </span><span class="n">msg_type</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">message_type</span><span class="p">(</span><span class="n">master_msg</span><span class="p">);</span>

<span class="w">    </span><span class="n">handle_wait_until_idle</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">msg_type</span><span class="p">,</span><span class="w"> </span><span class="n">master_msg</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">msg_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">add_msg</span><span class="w"> </span><span class="k">then</span>
<span class="w">      </span><span class="n">receive</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">slave_channel</span><span class="p">,</span><span class="w"> </span><span class="n">slave_msg</span><span class="p">);</span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="n">message_type</span><span class="p">(</span><span class="n">slave_msg</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum_msg</span><span class="w"> </span><span class="k">then</span>
<span class="w">        </span><span class="n">do_model_check</span><span class="p">(</span><span class="n">master_msg</span><span class="p">,</span><span class="w"> </span><span class="n">slave_msg</span><span class="p">);</span>
<span class="w">      </span><span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span>
<span class="w">  </span><span class="k">end</span><span class="w"> </span><span class="k">loop</span><span class="p">;</span>
<span class="k">end</span><span class="w"> </span><span class="k">process</span><span class="p">;</span>
</pre></div>
</div>
<p>In order for the test sequencer to know when the verification is complete it will send a <code class="docutils literal notranslate"><span class="pre">wait_for_idle</span></code> transaction
after all add transactions. That transaction is handled by the <code class="docutils literal notranslate"><span class="pre">handle_wait_until_idle</span></code> message handler on the
scoreboard side. The example test sequencer below just sends 10 random add messages separated by a random delay
(not good for functional coverage but good enough for this example).</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="k">loop</span>
<span class="w">  </span><span class="n">msg</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">new_msg</span><span class="p">(</span><span class="n">add_msg</span><span class="p">);</span>
<span class="w">  </span><span class="n">push</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">rnd</span><span class="p">.</span><span class="n">RandInt</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">255</span><span class="p">));</span>
<span class="w">  </span><span class="n">push</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">rnd</span><span class="p">.</span><span class="n">RandInt</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">255</span><span class="p">));</span>
<span class="w">  </span><span class="n">send</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">driver</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">);</span>
<span class="w">  </span><span class="n">wait_for_time</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">driver</span><span class="p">,</span><span class="w"> </span><span class="n">rnd</span><span class="p">.</span><span class="n">RandTime</span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="n">ns</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">clk_period</span><span class="p">));</span>
<span class="k">end</span><span class="w"> </span><span class="k">loop</span><span class="p">;</span>
<span class="n">wait_until_idle</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">master_channel</span><span class="p">);</span>
</pre></div>
</div>
<p>Subscribing to messages actively being published is the classic form of the publisher/subscriber communication pattern
while subscriptions on inbound or outbound traffic is more like eavesdropping. This has implications that you need to
be aware of:</p>
<ul class="simple">
<li><p>When receiving a message that has been published, a call to
<code class="docutils literal notranslate"><span class="pre">sender</span></code> or <code class="docutils literal notranslate"><span class="pre">receiver</span></code> on that message will return the publisher
and subscriber actors respectively. However, when receiving a
message resulting from an inbound or outbound subscription the two
functions will return the sender and the receiver for the original
message transaction.</p></li>
<li><p>The subscriber of inbound and outbound traffic will receive all
messages, not only those that would have been published if the
decision was more active. For example, if someone sends a
<code class="docutils literal notranslate"><span class="pre">wait_for_idle</span></code> transaction to the driver it will also be sent to
the subscriber which will act upon it “thinking” it was from the
test sequencer. This wouldn’t be a problem if we had a monitor for
the input interface only publishing add messages. It’s still
possible to fix though, for example by only handling
<code class="docutils literal notranslate"><span class="pre">wait_for_idle</span></code> transactions aimed at the master channel.</p></li>
</ul>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="n">receiver</span><span class="p">(</span><span class="n">master_msg</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">master_channel</span><span class="w"> </span><span class="k">then</span>
<span class="w">  </span><span class="n">handle_wait_until_idle</span><span class="p">(</span><span class="n">net</span><span class="p">,</span><span class="w"> </span><span class="n">msg_type</span><span class="p">,</span><span class="w"> </span><span class="n">master_msg</span><span class="p">);</span>
<span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Since you can subscribe on inbound traffic you can also subscribe to
the inbound traffic of a subscriber. This may not have great
practical value but can, if misused, create an infinite loop of
subscriptions which will hang the simulation.</p></li>
<li><p>A subscription on the outbound traffic of an actor won’t pick up messages sent anonymously.</p></li>
<li><p>A subscription on the inbound traffic of an actor won’t pick up replies to an anonymously request.</p></li>
</ul>
<section id="blocking-subscribers">
<h3>Blocking subscribers<a class="headerlink" href="#blocking-subscribers" title="Link to this heading">¶</a></h3>
<p>Although the intent of the publisher/subscriber pattern is to decouple the publisher from the subscribers it can still
be affected if a subscriber inbox is full. A message transaction will be blocked until all of its subscribers and any
regular receiver have available space in their inboxes.</p>
</section>
<section id="unsubscribing">
<h3>Unsubscribing<a class="headerlink" href="#unsubscribing" title="Link to this heading">¶</a></h3>
<p>An actor can unsubscribe from a subscription at any time by calling <code class="docutils literal notranslate"><span class="pre">unsubscribe</span></code> with the same parameters used when
calling the <code class="docutils literal notranslate"><span class="pre">subscribe</span></code> procedure.</p>
</section>
</section>
<section id="debugging">
<h2>Debugging<a class="headerlink" href="#debugging" title="Link to this heading">¶</a></h2>
<p>Message passing provides a communication mechanism an abstraction level above the normal signalling in VHDL.
This also means that there is a need for an equally elevated level of debugging. To support that <code class="docutils literal notranslate"><span class="pre">com</span></code> has
a number of built-in features specially targeting debugging.</p>
<section id="logging-messages">
<h3>Logging Messages<a class="headerlink" href="#logging-messages" title="Link to this heading">¶</a></h3>
<p>One way of debugging is to inspect the messages that flow through the system, for example by subscribing to actor
traffic. You can use previously presented functions to find out sender, receiver and message content but you can
also convert a message to a string such that it can be logged.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">to_string</span><span class="p">(</span><span class="n">reply_msg</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting string may look something like this</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">3:2 memory BFM -&gt; test sequencer (read reply)</span>
</pre></div>
</div>
<p>The first number (<code class="docutils literal notranslate"><span class="pre">3</span></code>) is the message ID which is unique to this message. The second number (<code class="docutils literal notranslate"><span class="pre">2</span></code>) is present
in reply messages and denotes the message ID for the request message. After that we have the sender
(<code class="docutils literal notranslate"><span class="pre">memory</span> <span class="pre">BFM</span></code>) which sent the message to (<code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>) the receiver (<code class="docutils literal notranslate"><span class="pre">test</span> <span class="pre">sequencer</span></code>). Finally, the value in
parentheses (<code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">reply</span></code>) is the message type. All communicated messages have a message ID but not all messages
are replies, sender and receivers may be anonymous and not all messages have a message type. Fields missing a
value will be replaced with <code class="docutils literal notranslate"><span class="pre">-</span></code>.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">com</span></code> has limited knowledge of the contents of a message. All data pushed into a message is encoded
and is basically handled as a sequence of bytes without any overhead for type information. <code class="docutils literal notranslate"><span class="pre">com</span></code> doesn’t
know if four bytes represents an integer, four characters or something else. The interpretation of
these bytes takes place when the user pops data using a type specific pop function. The exception is the message
type for which the type overhead is included to provide better debugging. Higher levels of debug information,
for example that a message represents a read request to a specific address is something that the verification
component using <code class="docutils literal notranslate"><span class="pre">com</span></code> provides.</p>
</section>
<section id="trace-log">
<h3>Trace Log<a class="headerlink" href="#trace-log" title="Link to this heading">¶</a></h3>
<p>Rather than manually logging messages you can quickly see all messages by showing the trace logs. <code class="docutils literal notranslate"><span class="pre">com</span></code> provides
a logger, <code class="docutils literal notranslate"><span class="pre">com_logger</span></code>, and you enable the trace logs by showing log entries on the <code class="docutils literal notranslate"><span class="pre">trace</span></code> log level.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">show</span><span class="p">(</span><span class="n">com_logger</span><span class="p">,</span><span class="w"> </span><span class="n">display_handler</span><span class="p">,</span><span class="w"> </span><span class="n">trace</span><span class="p">);</span>
</pre></div>
</div>
<p>Ignoring the initial part introduced by the logging framework (everything up to and including <code class="docutils literal notranslate"><span class="pre">TRACE</span> <span class="pre">-</span></code>) we
still see a difference when compared to the string presented above.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">30000 ps - vunit_lib:com -   TRACE - test sequencer inbox =&gt; [3:2 memory BFM -&gt; test sequencer (read reply)]</span>
</pre></div>
</div>
<p>First is an actor mailbox (<code class="docutils literal notranslate"><span class="pre">test</span> <span class="pre">sequencer</span> <span class="pre">inbox</span></code>), then an arrow (<code class="docutils literal notranslate"><span class="pre">=&gt;</span></code>) followed by the message string
enclosed in square brackets. This means that the message was removed from the mailbox, for example as a result
of a <code class="docutils literal notranslate"><span class="pre">receive_reply</span></code> call. <code class="docutils literal notranslate"><span class="pre">com</span></code> also logs when a message is put into a mailbox. In this
example that event is logged 10 ns earlier and is the result of a <code class="docutils literal notranslate"><span class="pre">reply</span></code> call</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">20000 ps - vunit_lib:com -   TRACE - [3:2 memory BFM -&gt; test sequencer (read reply)] =&gt; test sequencer inbox</span>
</pre></div>
</div>
<p>Now that we have all these transactions available it becomes possible to follow sequences of events. For example,
at time 0 ps we have the message with ID = 2 which is the request message for the reply above.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">0 ps - vunit_lib:com -   TRACE - [2:- test sequencer -&gt; memory BFM (read)] =&gt; memory BFM inbox</span>
</pre></div>
</div>
<p>Again, if you want higher level of debug information you can add debug logging to your BFM which may
result in something like this.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">    0 ps - vunit_lib:com -   TRACE - [2:- test sequencer -&gt; memory BFM (read)] =&gt; memory BFM inbox</span>
<span class="go">10000 ps - vunit_lib:com -   TRACE - memory BFM inbox =&gt; [2:- test sequencer -&gt; memory BFM (read)]</span>
<span class="go">20000 ps - memory BFM    -   DEBUG - Reading x&quot;21&quot; from address x&quot;80&quot;</span>
<span class="go">20000 ps - vunit_lib:com -   TRACE - [3:2 memory BFM -&gt; test sequencer (read reply)] =&gt; test sequencer inbox</span>
<span class="go">30000 ps - vunit_lib:com -   TRACE - test sequencer inbox =&gt; [3:2 memory BFM -&gt; test sequencer (read reply)]</span>
</pre></div>
</div>
</section>
<section id="state-information">
<h3>State Information<a class="headerlink" href="#state-information" title="Link to this heading">¶</a></h3>
<p>In addition to tracing messages you can also examine the state of the communication system. By calling
<code class="docutils literal notranslate"><span class="pre">get_mailbox_state</span></code> you can take a snapshot and examine all messages in an actor mailbox.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">mailbox_state</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">get_mailbox_state</span><span class="p">(</span><span class="n">memory_bfm_pkg</span><span class="p">.</span><span class="n">actor</span><span class="p">,</span><span class="w"> </span><span class="n">inbox</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">mailbox_state</span></code> is a record that you can expand and examine in your simulator. Be aware that this gives you a
glimpse of internal representations of data which we may change. It’s suitable for browsing but not something you
should act upon programmatically.</p>
<p>You can also create a string representation of the mailbox state by calling</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">get_mailbox_state_string</span><span class="p">(</span><span class="n">memory_bfm_pkg</span><span class="p">.</span><span class="n">actor</span><span class="p">,</span><span class="w"> </span><span class="n">inbox</span><span class="p">)</span>
</pre></div>
</div>
<p>The result is something like this</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Mailbox: inbox</span>
<span class="go">  Size: 2147483647</span>
<span class="go">  Messages:</span>
<span class="go">    0. 5:- _actor_3 -&gt; memory BFM (write)</span>
<span class="go">    1. 6:- _actor_3 -&gt; memory BFM (read)</span>
</pre></div>
</div>
<p>The size is the maximum number of messages that the mailbox can contain (this is dynamically allocated) while the
list at the bottom shows the actual messages in the mailbox. Message 0 is the oldest message and the first one
to be returned when you call <code class="docutils literal notranslate"><span class="pre">receive</span></code>.</p>
<p>You can also get an actor’s state as well as the string representation for that state</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">actor_state</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">get_actor_state</span><span class="p">(</span><span class="n">driver</span><span class="p">);</span>
<span class="n">debug</span><span class="p">(</span><span class="n">get_actor_state_string</span><span class="p">(</span><span class="n">driver</span><span class="p">));</span>
</pre></div>
</div>
<p>The string representation contains information about both mailboxes, subscriptions and subscribers and if the
actor’s creation is deferred. For example,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Name: driver</span>
<span class="go">  Is deferred: no</span>
<span class="go">  Mailbox: inbox</span>
<span class="go">    Size: 2147483647</span>
<span class="go">    Messages:</span>
<span class="go">      0. 8:- _actor_3 -&gt; driver (add)</span>
<span class="go">      1. 9:- _actor_3 -&gt; driver (add)</span>
<span class="go">      2. 10:- _actor_3 -&gt; driver (add)</span>
<span class="go">  Mailbox: outbox</span>
<span class="go">    Size: 2147483647</span>
<span class="go">    Messages:</span>
<span class="go">  Subscriptions:</span>
<span class="go">  Subscribers:</span>
<span class="go">    driver channel subscribes to inbound traffic</span>
</pre></div>
</div>
<p>In this case the outbox is empty and <cite>driver</cite> doesn’t subscribe to anything. However, the <code class="docutils literal notranslate"><span class="pre">driver</span> <span class="pre">channel</span></code>
actor subscribes to inbound traffic to <code class="docutils literal notranslate"><span class="pre">driver</span></code>.</p>
<p>Finally, you can get the state for the messenger which is the manager of the communication system. That state
contains two lists - one with the states of all active actors (those not deferred) and one with the states of
all deferred actors.</p>
<div class="highlight-vhdl notranslate"><div class="highlight"><pre><span></span><span class="n">messenger_state</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">get_messenger_state</span><span class="p">;</span>
<span class="n">debug</span><span class="p">(</span><span class="n">get_messenger_state_string</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<section id="deprecated-apis">
<h2>Deprecated APIs<a class="headerlink" href="#deprecated-apis" title="Link to this heading">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">com</span></code> maintains a number of deprecated APIs for better backward compatibility. Using these APIs will result in
a runtime error unless enabled by calling the <code class="docutils literal notranslate"><span class="pre">allow_deprecated</span></code> procedure.</p>
<p>Earlier releases of <code class="docutils literal notranslate"><span class="pre">com</span></code> would not cause a runtime error on timeout. This behavior can be enabled with the
deprecated APIs by calling <code class="docutils literal notranslate"><span class="pre">allow_timeout</span></code>. If not, a timeout will result in an error with the exception of the
<code class="docutils literal notranslate"><span class="pre">wait_for_messages</span></code> and <code class="docutils literal notranslate"><span class="pre">wait_for_reply</span></code> procedures which return a status.</p>
<p>The deprecated APIs will be removed in the future so it’s recommended to replace these with contemporary APIs.</p>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="../verification_components/user_guide.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Verification Components User Guide</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="../run/user_guide.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Run Library User Guide</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2014-2024, Lars Asplund
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              <a class="muted-link fa-solid fa-brands fa-twitter" href="https://twitter.com/VUnitFramework" aria-label="Twitter @VUnitFramework"></a>
              <a class="muted-link fa-solid fa-brands fa-gitter" href="https://gitter.im/VUnit/vunit" aria-label="Gitter VUnit/vunit"></a>
              <a class="muted-link fa-solid fa-brands fa-github" href="https://github.com/VUnit/vunit" aria-label="GitHub VUnit/vunit"></a>
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Communication Library User Guide</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#setup">Setup</a></li>
<li><a class="reference internal" href="#basic-message-passing">Basic Message Passing</a><ul>
<li><a class="reference internal" href="#sending-and-receiving">Sending and Receiving</a></li>
<li><a class="reference internal" href="#message-types">Message Types</a></li>
<li><a class="reference internal" href="#message-ownership">Message Ownership</a></li>
<li><a class="reference internal" href="#replying-to-a-message">Replying to a Message</a></li>
<li><a class="reference internal" href="#receiving-a-reply">Receiving a Reply</a></li>
<li><a class="reference internal" href="#signing-messages">Signing Messages</a></li>
<li><a class="reference internal" href="#sending-receiving-to-from-multiple-actors">Sending/Receiving to/from Multiple Actors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#synchronous-communication">Synchronous Communication</a></li>
<li><a class="reference internal" href="#message-handlers-and-verification-component-interfaces-vci">Message Handlers and Verification Component Interfaces (VCI)</a><ul>
<li><a class="reference internal" href="#timeout">Timeout</a></li>
<li><a class="reference internal" href="#deferred-actor-creation">Deferred Actor Creation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#publisher-subscriber-pattern">Publisher/Subscriber Pattern</a><ul>
<li><a class="reference internal" href="#blocking-subscribers">Blocking subscribers</a></li>
<li><a class="reference internal" href="#unsubscribing">Unsubscribing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#debugging">Debugging</a><ul>
<li><a class="reference internal" href="#logging-messages">Logging Messages</a></li>
<li><a class="reference internal" href="#trace-log">Trace Log</a></li>
<li><a class="reference internal" href="#state-information">State Information</a></li>
</ul>
</li>
<li><a class="reference internal" href="#deprecated-apis">Deprecated APIs</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=5fa4622c"></script>
    </body>
</html>