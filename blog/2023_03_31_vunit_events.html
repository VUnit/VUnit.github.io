<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="author" title="About these documents" href="../about.html"><link rel="index" title="Index" href="../genindex.html"><link rel="search" title="Search" href="../search.html"><link rel="next" title="VUnit User Conference" href="2022_09_19_vunit_user_conference.html"><link rel="prev" title="VUnit Phases" href="2023_04_01_vunit_phases.html">
        <link rel="prefetch" href="../_static/VUnit_logo.png" as="image">

    <link rel="shortcut icon" href="../_static/vunit.ico"><!-- Generated with Sphinx 7.3.7 and Furo 2025.12.19 -->
        <title>VUnit Events - VUnit documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d111a655" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=7bdb33bb" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=8dab3a3b" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/fontawesome.min.css" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/solid.min.css" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/brands.min.css" />
    
    


<style>
  body {
    --color-code-background: #f2f2f2;
  --color-code-foreground: #1e1e1e;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle site navigation sidebar">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc" aria-label="Toggle table of contents sidebar">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <span class="icon"><svg><use href="#svg-menu"></use></svg></span>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">VUnit  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="../_static/VUnit_logo.png" alt="Logo"/>
  </div>
  
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="index.html">Blog</a><input aria-label="Toggle navigation of Blog" checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="2023_08_26_vhdl_configurations.html">Improved Support for VHDL Configurations and OSVVM</a></li>
<li class="toctree-l2"><a class="reference internal" href="2023_04_01_vunit_phases.html">VUnit Phases</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">VUnit Events</a></li>
<li class="toctree-l2"><a class="reference internal" href="2022_09_19_vunit_user_conference.html">VUnit User Conference</a></li>
<li class="toctree-l2"><a class="reference internal" href="2022_09_06_vunit_and_other_frameworks.html">FAQ What is VUnit’s Relation to Other Verification Frameworks?</a></li>
<li class="toctree-l2"><a class="reference internal" href="2020_08_12_continuous_integration_with_vunit_action_in_10_lines_of_code.html">Continuous Integration With VUnit Action in 10 Lines of Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="2018_09_22_sigasi_adds_full_vunit_support.html">Sigasi Adds Full VUnit Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="2018_07_22_sigasi_deepens_its_commitment_to_the_vunit_testing_framework.html">Sigasi Deepens Its Commitment to the VUnit Testing Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="2018_03_22_vunit_community_developed_bfms.html">VUnit Community Developed BFMs</a></li>
<li class="toctree-l2"><a class="reference internal" href="2018_02_12_vunit3.html">VUnit 3.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="2017_12_14_vunit_bfms_as_simple_as_emailing.html">VUnit BFMs - as Simple as Emailing</a></li>
<li class="toctree-l2"><a class="reference internal" href="2017_11_23_vunit_matlab_integration.html">VUnit Matlab Integration</a></li>
<li class="toctree-l2"><a class="reference internal" href="2017_11_07_vunit_3_0_while_waiting_for_vhdl_2017.html">VUnit 3.0 - While Waiting for VHDL-2017</a></li>
<li class="toctree-l2"><a class="reference internal" href="2017_10_31_vunit_3_0_color_logging.html">VUnit 3.0 Color Logging</a></li>
<li class="toctree-l2"><a class="reference internal" href="2017_09_28_sigasi_adds_support_for_vunit_testing_framework.html">Sigasi Adds Support for VUnit Testing Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="2017_06_03_enable_your_simulator_to_handle_complex_top_level_generics.html">Enable Your Simulator to Handle Complex Top-Level Generics</a></li>
<li class="toctree-l2"><a class="reference internal" href="2017_01_12_vunit_getting_started_1_2_3.html">VUnit - Getting Started 1-2-3</a></li>
<li class="toctree-l2"><a class="reference internal" href="2016_11_22_vunit_the_best_value_for_initial_effort_part3.html">VUnit - The Best Value for Initial Effort - Part 3</a></li>
<li class="toctree-l2"><a class="reference internal" href="2016_11_16_vunit_the_best_value_for_initial_effort_part2.html">VUnit - The Best Value for Initial Effort - Part 2</a></li>
<li class="toctree-l2"><a class="reference internal" href="2016_11_15_vunit_the_best_value_for_initial_effort_part1.html">VUnit - The Best Value for Initial Effort - Part 1</a></li>
<li class="toctree-l2"><a class="reference internal" href="2016_08_08_making_osvvm_a_submodule.html">Making OSVVM a Git Submodule</a></li>
<li class="toctree-l2"><a class="reference internal" href="2016_02_21_improving_vhdl_testbench_design_with_message_passing.html">Improving VHDL Testbench Design with Message Passing</a></li>
<li class="toctree-l2"><a class="reference internal" href="2016_02_01_website_updates.html">Website Updates</a></li>
<li class="toctree-l2"><a class="reference internal" href="2016_01_29_chat_with_vunit_users_and_developers.html">Chat with VUnit Users and Developers</a></li>
<li class="toctree-l2"><a class="reference internal" href="2016_01_26_welcome_to_our_new_website.html">Welcome to Our New Website</a></li>
<li class="toctree-l2"><a class="reference internal" href="2015_12_15_free_and_open_source_verification_with_vunit_and_ghdl.html">Free and Open Source Verification with VUnit and GHDL</a></li>
<li class="toctree-l2"><a class="reference internal" href="2015_10_08_who_is_using_UVM.html">Who’s Using UVM (or Not) for FPGA Development, and Why?</a></li>
<li class="toctree-l2"><a class="reference internal" href="2015_09_24_short_introduction_to_vunit.html">Short Introduction to VUnit</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">About</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../about.html">What is VUnit?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installing.html">Installing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../testimonials/testimonials.html">Testimonials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user_guide.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../id/user_guide.html">Identity Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../logging/user_guide.html">Logging Library User Guide</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../check/user_guide.html">Check Library User Guide</a><input aria-label="Toggle navigation of Check Library User Guide" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../check/check_api.html"><em>check</em> package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../check/checker_pkg.html"><em>checker</em> package</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../run/user_guide.html">Run Library User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../com/user_guide.html">Communication Library User Guide</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../verification_components/user_guide.html">Verification Components User Guide</a><input aria-label="Toggle navigation of Verification Components User Guide" class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../verification_components/memory_model.html">Memory Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../verification_components/vci.html">Bus Master VCI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../verification_components/vci.html#stream-master-vci">Stream Master VCI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../verification_components/vci.html#stream-slave-vci">Stream Slave VCI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../verification_components/vci.html#synchronization-vci">Synchronization VCI</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../data_types/user_guide.html">Data Types User Guide</a><input aria-label="Toggle navigation of Data Types User Guide" class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../data_types/event_user_guide.html">VUnit Events</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data_types/queue.html"><em>queue</em> package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data_types/integer_array.html"><em>integer_array</em> package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data_types/ext_string.html"><em>external string</em> package</a></li>
<li class="toctree-l2"><a class="reference internal" href="../data_types/ext_integer_vector.html"><em>external integer vector</em> package</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../cli.html">Command Line Interface</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../py/ui.html">Python Interface</a><input aria-label="Toggle navigation of Python Interface" class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../py/vunit.html">vunit.ui</a></li>
<li class="toctree-l2"><a class="reference internal" href="../py/opts.html">Compilation Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="../py/opts.html#simulation-options">Simulation Options</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../hdl_libraries.html">HDL Libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Continuous Integration</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../ci/intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ci/script.html">Setup/configuration scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ci/container.html">Containers and/or Virtual Machines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ci/manual.html">Manual setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ci/usecases.html">Practical use cases</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../release_notes.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="https://github.com/VUnit/vunit/blob/master/docs/blog/2023_03_31_vunit_events.rst?plain=true" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div><div class="edit-this-page">
  <a class="muted-link" href="https://github.com/VUnit/vunit/edit/master/docs/blog/2023_03_31_vunit_events.rst" rel="edit" title="Edit this page">
    <svg><use href="#svg-pencil"></use></svg>
    <span class="visually-hidden">Edit this page</span>
  </a>
</div><div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section id="vunit-events">
<h1>VUnit Events<a class="headerlink" href="#vunit-events" title="Link to this heading">¶</a></h1>
<section id="what-you-will-learn">
<h2>What You Will Learn<a class="headerlink" href="#what-you-will-learn" title="Link to this heading">¶</a></h2>
<ol class="arabic simple">
<li><p>An improved method for synchronizing various components of your testbench.</p></li>
<li><p>Techniques to ensure your testbench does not terminate prematurely, before the DUT has been fully verified.</p></li>
<li><p>Ways to quickly identify where the testbench is stuck on timeout or other errors.</p></li>
<li><p>A method for generating a system “core dump” for easier debugging when errors are detected.</p></li>
</ol>
</section>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h2>
<p>Testbench code often requires the use of multiple concurrent processes to achieve various objectives.
These processes may be independent and run without regard to one another, or they may need to be synchronized to
coordinate their activities. An example of the first is an independent process driving a clock
and a common example of the latter is a bus functional model (BFM) that waits for another process to provide the
necessary address and data for the next bus transaction.</p>
<p>VUnit provides an event mechanism to facilitate such synchronization between processes. An event in this context
indicates that something has happened and can be used to notify other processes about that happening.
The other processes can then wait for the event to become active before proceeding with their tasks.</p>
<p>Before proceeding we need to distinguish the VUnit event mechanism from similar concepts. For example, VHDL
has its own event concept for signals, which allows processes to wait for a signal event using the wait statement.</p>
<div class="highlight"><pre><span></span><span class="k">wait</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">new_data_set</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>A common misunderstanding is that the wait statement will be activated if the process responsible
for driving the <code class="docutils literal notranslate"><span class="pre">new_data_set</span></code> signal makes an assignment to it. However, this is not the case.
In VHDL, the wait statement will remain blocked unless there is a <strong>change</strong> in the value of the signal. Let’s say
the core of the data producing process is as follows:</p>
<div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="n">data_set</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="k">loop</span><span class="w"></span>
<span class="w">  </span><span class="n">produce_data</span><span class="p">(</span><span class="n">data_set</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">new_data_set</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">true</span><span class="p">;</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="k">loop</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>The process waiting for data looks like this:</p>
<div class="highlight"><pre><span></span><span class="n">listening_to_vhdl_events</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">process</span><span class="w"> </span><span class="k">is</span><span class="w"></span>
<span class="w">  </span><span class="k">constant</span><span class="w"> </span><span class="n">logger</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">logger_t</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">get_logger</span><span class="p">(</span><span class="s">&quot;Process waiting on VHDL events&quot;</span><span class="p">);</span><span class="w"></span>
<span class="k">begin</span><span class="w"></span>
<span class="w">  </span><span class="k">wait</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">new_data_set</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">trace</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Got new data set&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">handle</span><span class="p">(</span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="k">process</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>If the intial value of <code class="docutils literal notranslate"><span class="pre">new_data_set</span></code> is <code class="docutils literal notranslate"><span class="pre">false</span></code>, the waiting process will react to the first assignment,
but miss all subsequent events and data. To fix this issue,  we can use the <code class="docutils literal notranslate"><span class="pre">transaction</span></code> attribute on the signal.
Every VHDL assignment is considered a <em>transaction</em> and the process below should not miss any data.</p>
<div class="highlight"><pre><span></span><span class="n">listening_to_vhdl_transactions</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">process</span><span class="w"> </span><span class="k">is</span><span class="w"></span>
<span class="w">  </span><span class="k">constant</span><span class="w"> </span><span class="n">logger</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">logger_t</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">get_logger</span><span class="p">(</span><span class="s">&quot;Process waiting on VHDL transactions&quot;</span><span class="p">);</span><span class="w"></span>
<span class="k">begin</span><span class="w"></span>
<span class="w">  </span><span class="k">wait</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">new_data_set</span><span class="na">&#39;transaction</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">trace</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Got new data set&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">handle</span><span class="p">(</span><span class="n">data</span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="k">process</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>This is confirmed by the simulation trace log, which shows that the latter receiving process works as intended, while
the first process misses all but the first event.</p>
<div class="highlight" style="background: #002b36; color: #eee8d5;"><pre style="line-height: 125%; background: #002b36; color: #eee8d5;"><span style="color: #2aa198; ">1000 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">Process waiting on VHDL events</span>       -   <span style="font_weight: bold; color: #9c36b6; ">TRACE</span> - Got new data set (tb_traditional.vhd:81)
<span style="color: #2aa198; ">1000 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">Process waiting on VHDL transactions</span> -   <span style="font_weight: bold; color: #9c36b6; ">TRACE</span> - Got new data set (tb_traditional.vhd:93)
<span style="color: #2aa198; ">2000 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">Process waiting on VHDL transactions</span> -   <span style="font_weight: bold; color: #9c36b6; ">TRACE</span> - Got new data set (tb_traditional.vhd:93)
<span style="color: #2aa198; ">3000 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">Process waiting on VHDL transactions</span> -   <span style="font_weight: bold; color: #9c36b6; ">TRACE</span> - Got new data set (tb_traditional.vhd:93)
</pre></div>
<p>Another solution to this problem is to toggle the event signal rather than setting it to <code class="docutils literal notranslate"><span class="pre">true</span></code>:</p>
<div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="n">data_set</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="k">loop</span><span class="w"></span>
<span class="w">  </span><span class="n">produce_data</span><span class="p">(</span><span class="n">data_set</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">new_data_set</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="n">new_data_set</span><span class="p">;</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="k">loop</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>Although the signal name may now seem a bit misleading, we no longer need the <code class="docutils literal notranslate"><span class="pre">transaction</span></code> attribute for the wait
statement to function properly, as shown in this log:</p>
<div class="highlight" style="background: #002b36; color: #eee8d5;"><pre style="line-height: 125%; background: #002b36; color: #eee8d5;"><span style="color: #2aa198; ">1000 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">Process waiting on VHDL events</span>       -   <span style="font_weight: bold; color: #9c36b6; ">TRACE</span> - Got new data set (tb_traditional.vhd:81)
<span style="color: #2aa198; ">1000 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">Process waiting on VHDL transactions</span> -   <span style="font_weight: bold; color: #9c36b6; ">TRACE</span> - Got new data set (tb_traditional.vhd:93)
<span style="color: #2aa198; ">2000 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">Process waiting on VHDL events</span>       -   <span style="font_weight: bold; color: #9c36b6; ">TRACE</span> - Got new data set (tb_traditional.vhd:81)
<span style="color: #2aa198; ">2000 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">Process waiting on VHDL transactions</span> -   <span style="font_weight: bold; color: #9c36b6; ">TRACE</span> - Got new data set (tb_traditional.vhd:93)
<span style="color: #2aa198; ">3000 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">Process waiting on VHDL events</span>       -   <span style="font_weight: bold; color: #9c36b6; ">TRACE</span> - Got new data set (tb_traditional.vhd:81)
<span style="color: #2aa198; ">3000 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">Process waiting on VHDL transactions</span> -   <span style="font_weight: bold; color: #9c36b6; ">TRACE</span> - Got new data set (tb_traditional.vhd:93)
</pre></div>
<p>There are also other approaches that can be used, but the main point is that creating events that behave as intended
requires an understanding of the inner workings of VHDL, and such details are better hidden behind an abstraction
to prevent confusion and mistakes. By establishing an abstraction, it is also possible to further extend the event
functionality without adding unnecessary complexity to the user’s code. These are the main motivations for the
VUnit event types.</p>
<p>This is a similar step to how the design of synchronous processes has evolved over time. Previously, they were based
on the <code class="docutils literal notranslate"><span class="pre">clk'event</span> <span class="pre">and</span> <span class="pre">clk</span> <span class="pre">=</span> <span class="pre">'1'</span></code> condition, but now the more common approach is to use <code class="docutils literal notranslate"><span class="pre">rising_edge(clk)</span></code>. The
latter hides the details of VHDL events and is a more powerful solution. While the previous solution would react to a
<code class="docutils literal notranslate"><span class="pre">std_logic</span></code> <code class="docutils literal notranslate"><span class="pre">clk</span></code> changing from <code class="docutils literal notranslate"><span class="pre">X</span></code> to <code class="docutils literal notranslate"><span class="pre">1</span></code>, or even worse from <code class="docutils literal notranslate"><span class="pre">H</span></code> to <code class="docutils literal notranslate"><span class="pre">1</span></code>, the latter correctly does not.</p>
<p>Another synchronization mechanism that is often confused with the VUnit style of events is the binary semaphore.
The main difference is that an event occurs at a <strong>point in time</strong>, and a process starting to wait for an event will
block until the <strong>next</strong> event occurs. Binary semaphores, on the other hand, have a binary state. One of the states,
often denoted with the integer 1 and representing the availablity of some resource, allow a process to proceed
immediately regardless of whether the state was active when the process started waiting. There is no need for something
to happen, an event, in order for the process to proceed. A semaphore checks its state first and only if the value is 0
there is a need to wait for the event indicating that the state has been set to 1. After a process has been allowed to
proceed, it will set the semaphore value to 0 to prevent other processes from claiming the resource.</p>
<p>Events can be used not only to build semaphores, but also to create other, more complex synchronization mechanisms.
VUnit message passing is an example of such a mechanism that is based on events.
If you have used it, you may have noticed the <code class="docutils literal notranslate"><span class="pre">net</span></code> signal appearing in many subprogram calls and wondered what it
is used for. The answer is that <code class="docutils literal notranslate"><span class="pre">net</span></code> is an event that indicates that something has happened in the message passing
system. In addition to the <code class="docutils literal notranslate"><span class="pre">net</span></code> event, VUnit provides other events that are useful to users. We will discuss some of
these events in this guide.</p>
</section>
<section id="two-types-of-vunit-events">
<h2>Two Types of VUnit Events<a class="headerlink" href="#two-types-of-vunit-events" title="Link to this heading">¶</a></h2>
<p>VUnit events come in two types: <code class="docutils literal notranslate"><span class="pre">basic_event_t</span></code> and <code class="docutils literal notranslate"><span class="pre">event_t</span></code>. <code class="docutils literal notranslate"><span class="pre">basic_event_t</span></code> events, such as <code class="docutils literal notranslate"><span class="pre">net</span></code>, are
provided by the VUnit framework and behave similarly to user-defined events of type <code class="docutils literal notranslate"><span class="pre">event_t</span></code>. The main difference is
that basic events are predefined rather than dynamically created. Predefined events enable us to create a
cleaner architecture within VUnit where low-level functionality can use events without creating many dependencies on
other parts of VUnit. However, from a user-point of view the basic events behave very similar to user-defined events and
provide the same user interface. For that reason we’ll start explaining <code class="docutils literal notranslate"><span class="pre">event_t</span></code> before presenting the basic
events.</p>
</section>
<section id="user-defined-events">
<h2>User-Defined Events<a class="headerlink" href="#user-defined-events" title="Link to this heading">¶</a></h2>
<p>User-defined events can be created from identities (see <a class="reference internal" href="../id/user_guide.html#id-user-guide"><span class="std std-ref">identity package</span></a>) or directly from a
name string. In the latter case an identity is created automatically for that name unless it already exists.</p>
<blockquote>
<div><div class="highlight"><pre><span></span><span class="k">signal</span><span class="w"> </span><span class="n">new_data_set</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">event_t</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">new_event</span><span class="p">(</span><span class="s">&quot;new_data_set&quot;</span><span class="p">);</span><span class="w"></span>
<span class="c1">-- The above is equivalent to</span><span class="w"></span>
<span class="c1">-- signal new_data_set : event_t := new_event(get_id(&quot;new_data_set&quot;));</span><span class="w"></span>
</pre></div>
</div></blockquote>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>An event is always declared as a signal.</p>
</div>
<p>In the following example, we have two processes: the <code class="docutils literal notranslate"><span class="pre">test_runner</span></code> process and the <code class="docutils literal notranslate"><span class="pre">dut_checker</span></code>
process. <code class="docutils literal notranslate"><span class="pre">test_runner</span></code> generates stimuli input for the device under test (DUT) and <code class="docutils literal notranslate"><span class="pre">dut_checker</span></code>
verifies the DUT’s response to that stimuli. The stimuli is created from a number of data set files
and <code class="docutils literal notranslate"><span class="pre">test_runner</span></code> starts by pushing the total number of samples in each set to a VUnit queue. Next, it notifies
<code class="docutils literal notranslate"><span class="pre">dut_checker</span></code> via the <code class="docutils literal notranslate"><span class="pre">new_data_set</span></code> event. <code class="docutils literal notranslate"><span class="pre">test_runner</span></code> then pushes the individual sample values to the same
queue.</p>
<p>The code below shows the body of the <code class="docutils literal notranslate"><span class="pre">test_runner</span></code> process but also a <code class="docutils literal notranslate"><span class="pre">test_runner_watchdog</span></code>. We’ll
get back to that later.</p>
<blockquote>
<div><div class="highlight"><pre><span></span><span class="k">begin</span><span class="w"></span>
<span class="w">  </span><span class="n">test_runner_setup</span><span class="p">(</span><span class="n">runner</span><span class="p">,</span><span class="w"> </span><span class="n">runner_cfg</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">data_set_idx</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">n_data_sets</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">loop</span><span class="w"></span>
<span class="w">    </span><span class="n">data_set</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">load_data_from_file</span><span class="p">(</span><span class="n">data_set_idx</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">n_samples</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">length</span><span class="p">(</span><span class="n">data_set</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">push</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span><span class="w"> </span><span class="n">n_samples</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">notify</span><span class="p">(</span><span class="n">new_data_set</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">sample_idx</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">n_samples</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">loop</span><span class="w"></span>
<span class="w">      </span><span class="n">sample</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="n">data_set</span><span class="p">,</span><span class="w"> </span><span class="n">sample_idx</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">drive_dut</span><span class="p">(</span><span class="n">sample</span><span class="p">);</span><span class="w"></span>
<span class="w">      </span><span class="n">push</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span><span class="w"> </span><span class="n">sample</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">end</span><span class="w"> </span><span class="k">loop</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"> </span><span class="k">loop</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="n">test_runner_cleanup</span><span class="p">(</span><span class="n">runner</span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="k">process</span><span class="p">;</span><span class="w"></span>

<span class="n">test_runner_watchdog</span><span class="p">(</span><span class="n">runner</span><span class="p">,</span><span class="w"> </span><span class="mi">500</span><span class="w"> </span><span class="n">ns</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div></blockquote>
<p>If the queue is empty, the <code class="docutils literal notranslate"><span class="pre">dut_checker</span></code> process waits for the <code class="docutils literal notranslate"><span class="pre">new_data_set</span></code> event to be activated using the
<code class="docutils literal notranslate"><span class="pre">is_active</span></code> function. When the event arrives, <code class="docutils literal notranslate"><span class="pre">dut_checker</span></code> pops the number of samples to expect from the queue.
It then waits for that number of outputs from the DUT, and for each output it pops the corresponding input sample from
the queue in order to calculate the expected output. The expected value is then compared to the actual value. The
<code class="docutils literal notranslate"><span class="pre">dut_checker</span></code> process operates in parallel with the <code class="docutils literal notranslate"><span class="pre">test_runner</span></code> process but is slightly separated in time due to
the latency of the DUT.</p>
<blockquote>
<div><div class="highlight"><pre><span></span><span class="n">dut_checker</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">process</span><span class="w"></span>
<span class="k">begin</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">is_empty</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w"></span>
<span class="w">    </span><span class="k">wait</span><span class="w"> </span><span class="k">until</span><span class="w"> </span><span class="n">is_active</span><span class="p">(</span><span class="n">new_data_set</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">pop</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span><span class="w"> </span><span class="k">loop</span><span class="w"></span>
<span class="w">    </span><span class="k">wait</span><span class="w"> </span><span class="k">until</span><span class="w"> </span><span class="n">rising_edge</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">output_tvalid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">check_equal</span><span class="p">(</span><span class="n">output_tdata</span><span class="p">,</span><span class="w"> </span><span class="n">calculate_expected_output</span><span class="p">(</span><span class="n">pop</span><span class="p">(</span><span class="n">queue</span><span class="p">)));</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"> </span><span class="k">loop</span><span class="p">;</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="k">process</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div></blockquote>
<p>After <code class="docutils literal notranslate"><span class="pre">dut_checker</span></code> has received and checked the expected number of values it will
look for a new data set in the queue and wait if not already present. In this case there is no need to wait
because <code class="docutils literal notranslate"><span class="pre">test_runner</span></code> is applying the data sets back-to-back and operates ahead of <code class="docutils literal notranslate"><span class="pre">dut_checker</span></code>
due to the DUT’s latency.</p>
<p>The design described in the previous sections has a major issue that needs to be addressed: when <code class="docutils literal notranslate"><span class="pre">test_runner</span></code> has
driven the last sample of the last data set, it directly calls the <code class="docutils literal notranslate"><span class="pre">test_runner_cleanup</span></code> function before the DUT has
processed and output the result of all stimuli. As a result, there are DUT outputs that are never verified. One common
fix for this problem is to insert a wait statement before the <code class="docutils literal notranslate"><span class="pre">test_runner_cleanup</span></code> function that adds a few clock
cycles of delay, allowing the DUT pipeline to drain of all remaining data. However, this is a very dangerous solution
as it relies on the latency of the DUT remaining constant. If the latency of the DUT increases due to updates to the
design, the delay may not be sufficient and the issue will reappear. Additionally, if there is a bug that causes the
DUT not to produce all outputs, or perhaps no outputs at all, the delay will expire regardless of how much safety
margin is added, resulting in a potentially faulty test being marked as passing. A more robust solution is needed to
ensure that all results are properly verified.</p>
<p>The key here is that we’ve assigned the task of verifying the output to the <code class="docutils literal notranslate"><span class="pre">dut_checker</span></code> process. Only this process
can determine when the task is fully completed. Therefore, we will create a second event called <code class="docutils literal notranslate"><span class="pre">dut_checker_done</span></code>.
<code class="docutils literal notranslate"><span class="pre">dut_checker</span></code> will signal this event when it has verified a data set and can’t find any new input in the queue. It
will still go and wait for more input in case it comes later.</p>
<blockquote>
<div><div class="highlight"><pre><span></span><span class="n">dut_checker</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">process</span><span class="w"></span>
<span class="k">begin</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">is_empty</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w"></span>
<span class="w">    </span><span class="k">wait</span><span class="w"> </span><span class="k">until</span><span class="w"> </span><span class="n">is_active</span><span class="p">(</span><span class="n">new_data_set</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">pop</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span><span class="w"> </span><span class="k">loop</span><span class="w"></span>
<span class="w">    </span><span class="k">wait</span><span class="w"> </span><span class="k">until</span><span class="w"> </span><span class="n">rising_edge</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">output_tvalid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">check_equal</span><span class="p">(</span><span class="n">output_tdata</span><span class="p">,</span><span class="w"> </span><span class="n">calculate_expected_output</span><span class="p">(</span><span class="n">pop</span><span class="p">(</span><span class="n">queue</span><span class="p">)));</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"> </span><span class="k">loop</span><span class="p">;</span><span class="w"></span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">is_empty</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w"></span>
<span class="w">    </span><span class="n">notify</span><span class="p">(</span><span class="n">dut_checker_done</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="k">process</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div></blockquote>
<p>In <code class="docutils literal notranslate"><span class="pre">test_runner</span></code> we add a safety barrier by waiting for this event before calling <code class="docutils literal notranslate"><span class="pre">test_runner_cleanup</span></code>.</p>
<blockquote>
<div><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">wait</span><span class="w"> </span><span class="k">until</span><span class="w"> </span><span class="n">is_active_msg</span><span class="p">(</span><span class="n">dut_checker_done</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">test_runner_cleanup</span><span class="p">(</span><span class="n">runner</span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="k">process</span><span class="p">;</span><span class="w"></span>

<span class="n">test_runner_watchdog</span><span class="p">(</span><span class="n">runner</span><span class="p">,</span><span class="w"> </span><span class="mi">500</span><span class="w"> </span><span class="n">ns</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div></blockquote>
<p>In this case we’re using <code class="docutils literal notranslate"><span class="pre">is_active_msg</span></code> instead of <code class="docutils literal notranslate"><span class="pre">is_active</span></code>. It has the same function but also produces a log
message when the input event is active.</p>
<blockquote>
<div><div class="highlight" style="background: #002b36; color: #eee8d5;"><pre style="line-height: 125%; background: #002b36; color: #eee8d5;">     <span style="color: #2aa198; ">0 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">default</span>                      -    <span style="font_weight: bold; color: #eee8d5; ">INFO</span> - Identity hierarchy: (tb_event.vhd:134)
                                                     dut_checker
                                                     \---done
<span style="color: #2aa198; ">326000 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">vunit_lib</span><span style="font_weight: bold; color: #2aa198; ">:</span><span style="font_weight: bold; color: #eee8d5; ">event_pkg</span>          -    <span style="font_weight: bold; color: #eee8d5; ">INFO</span> - Event dut_checker:done activated (tb_event.vhd:151)
</pre></div>
</div></blockquote>
<p>Also note that we gave the event a hierarchical name <code class="docutils literal notranslate"><span class="pre">dut_checker:done</span></code>, i.e.
the event <code class="docutils literal notranslate"><span class="pre">done</span></code> is owned by the <code class="docutils literal notranslate"><span class="pre">dut_checker</span></code> (pretty-printing of the identity hierarchy is done by the
<code class="docutils literal notranslate"><span class="pre">get_tree</span></code> function in the <a class="reference internal" href="../id/user_guide.html#id-user-guide"><span class="std std-ref">identity package</span></a>).</p>
<p>With the new event we have a more solid strategy for terminating the simulation, so let’s experiment to see what happens
if a new bug in the DUT causes it to stop producing data prematurely:</p>
<blockquote>
<div><div class="highlight" style="background: #002b36; color: #eee8d5;"><pre style="line-height: 125%; background: #002b36; color: #eee8d5;"><span style="color: #2aa198; ">500000 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">runner</span>                       -   <span style="font_weight: bold; color: #cb4b16; ">ERROR</span> - Test runner timeout after 500000 ps. (tb_event.vhd:155)
</pre></div>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">test_runner_watchdog</span></code> mentioned previously helps us identify this issue, and in this simple
example, it’s relatively easy to find the root cause. However, in more complex situations, it can be challenging to
know where to begin debugging because there are many potential points where the testbench may become stuck. VUnit
provides a number of basic events that are useful in situations like these.</p>
</section>
<section id="vunit-provided-events">
<h2>VUnit-Provided Events<a class="headerlink" href="#vunit-provided-events" title="Link to this heading">¶</a></h2>
<p>A method to identify blocking wait statements that cause the simulation to timeout is to use the VUnit-provided
<code class="docutils literal notranslate"><span class="pre">runner_timeout</span></code> event in combination with the <code class="docutils literal notranslate"><span class="pre">log_active</span></code> function. The <code class="docutils literal notranslate"><span class="pre">log_active</span></code> function produces a
log message just like <code class="docutils literal notranslate"><span class="pre">is_active_msg</span></code> but it always returns <code class="docutils literal notranslate"><span class="pre">false</span></code>. This means it can be used to identify
blocking wait statements without unblocking them. We can use this in the <code class="docutils literal notranslate"><span class="pre">dut_checker</span></code> wait statement.</p>
<blockquote>
<div><div class="highlight"><pre><span></span><span class="k">wait</span><span class="w"> </span><span class="k">until</span><span class="w"> </span><span class="p">(</span><span class="n">rising_edge</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">output_tvalid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="n">log_active</span><span class="p">(</span><span class="n">runner_timeout</span><span class="p">);</span><span class="w"></span>
<span class="n">check_equal</span><span class="p">(</span><span class="n">output_tdata</span><span class="p">,</span><span class="w"> </span><span class="n">calculate_expected_output</span><span class="p">(</span><span class="n">pop</span><span class="p">(</span><span class="n">queue</span><span class="p">)));</span><span class="w"></span>
</pre></div>
</div></blockquote>
<p>This addition will create an extra log entry and the location information pinpoints the exact location of the
wait statement.</p>
<blockquote>
<div><div class="highlight" style="background: #002b36; color: #eee8d5;"><pre style="line-height: 125%; background: #002b36; color: #eee8d5;"><span style="color: #2aa198; ">500000 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">vunit_lib</span><span style="font_weight: bold; color: #2aa198; ">:</span><span style="font_weight: bold; color: #eee8d5; ">event_pkg</span>          -    <span style="font_weight: bold; color: #eee8d5; ">INFO</span> - Event runner:timeout activated (tb_event.vhd:368)
<span style="color: #2aa198; ">500000 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">runner</span>                       -   <span style="font_weight: bold; color: #cb4b16; ">ERROR</span> - Test runner timeout after 500000 ps. (tb_event.vhd:155)
</pre></div>
</div></blockquote>
<p>If you are using Active-HDL or Riviera-PRO and compiling your code with VHDL-2019, log location is automatically
supported. If that is no option, you can use VUnit’s location preprocessor to achieve the same result
(see <a class="reference internal" href="../logging/user_guide.html#logging-library-loglocation"><span class="std std-ref">Log Location</span></a>). If you are not using either of these options, the extra
entry (or entries if you have multiple wait statements) will not be helpful. However, there are other ways to identify
the problematic wait statement(s):</p>
<ol class="arabic simple">
<li><p>Use a Custom logger</p></li>
</ol>
<blockquote>
<div><p>We can create a logger representing <code class="docutils literal notranslate"><span class="pre">dut_checker</span></code> using either identities or a name string like this:</p>
<div class="highlight"><pre><span></span><span class="k">constant</span><span class="w"> </span><span class="n">dut_checker_logger</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">logger_t</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">get_logger</span><span class="p">(</span><span class="s">&quot;dut_checker&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>Next, we hand <code class="docutils literal notranslate"><span class="pre">dut_checker_logger</span></code> to the <code class="docutils literal notranslate"><span class="pre">log_active</span></code> function.</p>
<div class="highlight"><pre><span></span><span class="k">wait</span><span class="w"> </span><span class="k">until</span><span class="w"> </span><span class="p">(</span><span class="n">rising_edge</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">output_tvalid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="n">log_active</span><span class="p">(</span><span class="n">runner_timeout</span><span class="p">,</span><span class="w"> </span><span class="n">logger</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">dut_checker_logger</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>This will bring our log message closer to the source (<code class="docutils literal notranslate"><span class="pre">dut_checker</span></code>) should we not have the exact location.</p>
<div class="highlight" style="background: #002b36; color: #eee8d5;"><pre style="line-height: 125%; background: #002b36; color: #eee8d5;"><span style="color: #2aa198; ">500000 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">dut_checker</span>                  -    <span style="font_weight: bold; color: #eee8d5; ">INFO</span> - Event runner:timeout activated (tb_event.vhd:392)
<span style="color: #2aa198; ">500000 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">runner</span>                       -   <span style="font_weight: bold; color: #cb4b16; ">ERROR</span> - Test runner timeout after 500000 ps. (tb_event.vhd:155)
</pre></div>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>Use a Custom Message</p></li>
</ol>
<blockquote>
<div><p>In case <code class="docutils literal notranslate"><span class="pre">dut_checker</span></code> has several wait statements and we want to know which one is stuck, we can add a
message to <code class="docutils literal notranslate"><span class="pre">log_active</span></code>.</p>
<div class="highlight"><pre><span></span><span class="k">wait</span><span class="w"> </span><span class="k">until</span><span class="w"> </span><span class="p">(</span><span class="n">rising_edge</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">output_tvalid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="n">log_active</span><span class="p">(</span><span class="n">runner_timeout</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Waiting on output data&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">logger</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">dut_checker_logger</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>The source of the problem is easier to identify but at the expense of losing information about why the log
entry was produced (the runner:timeout event was activated).</p>
<div class="highlight" style="background: #002b36; color: #eee8d5;"><pre style="line-height: 125%; background: #002b36; color: #eee8d5;"><span style="color: #2aa198; ">500000 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">dut_checker</span>                  -    <span style="font_weight: bold; color: #eee8d5; ">INFO</span> - Waiting on output data (tb_event.vhd:396)
<span style="color: #2aa198; ">500000 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">runner</span>                       -   <span style="font_weight: bold; color: #cb4b16; ">ERROR</span> - Test runner timeout after 500000 ps. (tb_event.vhd:155)
</pre></div>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>Use a Decorated Message</p></li>
</ol>
<blockquote>
<div><p>We can restore the lost event information by using a decorated message. Decoration is done with the <code class="docutils literal notranslate"><span class="pre">decorate</span></code>
function which combines the automatically generated information with a message provided by the user. This technique
may be familiar to those who have used the <code class="docutils literal notranslate"><span class="pre">result</span></code> function in check subprograms. <code class="docutils literal notranslate"><span class="pre">result</span></code> implements the same
idea and is actually an alias for <code class="docutils literal notranslate"><span class="pre">decorate</span></code>.</p>
<div class="highlight"><pre><span></span><span class="k">wait</span><span class="w"> </span><span class="k">until</span><span class="w"> </span><span class="p">(</span><span class="n">rising_edge</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">output_tvalid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="n">log_active</span><span class="p">(</span><span class="n">runner_timeout</span><span class="p">,</span><span class="w"> </span><span class="n">decorate</span><span class="p">(</span><span class="s">&quot;while waiting on output data&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">logger</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">dut_checker_logger</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>The resulting log is as follows:</p>
<div class="highlight" style="background: #002b36; color: #eee8d5;"><pre style="line-height: 125%; background: #002b36; color: #eee8d5;"><span style="color: #2aa198; ">500000 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">dut_checker</span>                  -    <span style="font_weight: bold; color: #eee8d5; ">INFO</span> - Event runner:timeout activated while waiting on output data (tb_event.vhd:400)
<span style="color: #2aa198; ">500000 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">runner</span>                       -   <span style="font_weight: bold; color: #cb4b16; ">ERROR</span> - Test runner timeout after 500000 ps. (tb_event.vhd:155)
</pre></div>
</div></blockquote>
<p>Using events to identify blocking wait statements is useful not only for timeout errors, but for any type of error.
VUnit offers a more generic <code class="docutils literal notranslate"><span class="pre">vunit_error</span></code> event that is activated in addition to the <code class="docutils literal notranslate"><span class="pre">runner_timeout</span></code> event and
can be activated from other error sources as well, including errors found by the testbench itself.</p>
<blockquote>
<div><div class="highlight"><pre><span></span><span class="k">wait</span><span class="w"> </span><span class="k">until</span><span class="w"> </span><span class="p">(</span><span class="n">rising_edge</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">output_tvalid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="n">log_active</span><span class="p">(</span><span class="n">vunit_error</span><span class="p">,</span><span class="w"> </span><span class="n">decorate</span><span class="p">(</span><span class="s">&quot;while waiting on output data&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">logger</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">dut_checker_logger</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div></blockquote>
<p>Let’s say we have a requirement on the maximum latency for our DUT and we want to check that. To do that we decide to
apply the first data set on the DUT input, wait for the maximum latency, and then read a status register in the DUT
containing a field with the number of processed samples. We expect that field to be the number of samples applied
if the latency is within the requirement. This piece of code is placed after the loop applying all samples in a data
set.</p>
<blockquote>
<div><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="n">data_set_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">then</span><span class="w"></span>
<span class="w">  </span><span class="k">wait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">max_latency</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">read_register</span><span class="p">(</span><span class="n">status_reg_addr</span><span class="p">,</span><span class="w"> </span><span class="n">status</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">check_equal</span><span class="p">(</span><span class="n">status</span><span class="p">(</span><span class="n">n_samples_field</span><span class="p">),</span><span class="w"> </span><span class="n">n_samples</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">(</span><span class="s">&quot;for #processed samples&quot;</span><span class="p">));</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div></blockquote>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Register fields in VHDL can be defined by creating an integer subtype with the range set to the range of bits
occupied by the field. In this case <code class="docutils literal notranslate"><span class="pre">n_samples_field</span></code> is defined as:</p>
<div class="highlight"><pre><span></span><span class="k">subtype</span><span class="w"> </span><span class="n">n_samples_field</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="kt">integer</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="k">downto</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Running this code reveals that only half of the applied samples have been processed after the maximum latency.</p>
<blockquote>
<div><div class="highlight" style="background: #002b36; color: #eee8d5;"><pre style="line-height: 125%; background: #002b36; color: #eee8d5;"><span style="color: #2aa198; ">174000 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">check</span>                        -   <span style="font_weight: bold; color: #cb4b16; ">ERROR</span> - Equality check failed for #processed samples - Got 0000_0101 (5). Expected 10 (0000_1010). (tb_event.vhd:206)
</pre></div>
</div></blockquote>
<p>If we could notify <code class="docutils literal notranslate"><span class="pre">vunit_error</span></code> when we encounter this error, we would expect <code class="docutils literal notranslate"><span class="pre">dut_checker</span></code>’s wait statement
for output data to create a log entry since not all data have been produced. That would help confirming the latency
issue. To do that we need to divide the <code class="docutils literal notranslate"><span class="pre">check_equal</span></code> procedure into two parts: the analysis and the action. The
analysis compares the expected and actual number of samples, while the action logs an error in response to a failing
equality as determined by the analysis.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">check_equal</span></code> procedure has an equivalent function that only performs the analysis and returns the
result. There is also a <code class="docutils literal notranslate"><span class="pre">log</span></code> procedure that takes the result as input and performs the action part. To address the
issue we are facing, we want to have an alternative action procedure that notifies <code class="docutils literal notranslate"><span class="pre">vunit_error</span></code> if the result
indicates a failing equality and <em>then</em> calls the <code class="docutils literal notranslate"><span class="pre">log</span></code> procedure. This alternative action procedure, called
<code class="docutils literal notranslate"><span class="pre">notify_if_fail</span></code>, is already provided and takes the analysis result and an event to notify on failure as input.</p>
<blockquote>
<div><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="n">data_set_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">then</span><span class="w"></span>
<span class="w">  </span><span class="k">wait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">max_latency</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">read_register</span><span class="p">(</span><span class="n">status_reg_addr</span><span class="p">,</span><span class="w"> </span><span class="n">status</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="k">wait</span><span class="w"> </span><span class="k">until</span><span class="w"> </span><span class="n">rising_edge</span><span class="p">(</span><span class="n">clk</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">notify_if_fail</span><span class="p">(</span><span class="n">check_equal</span><span class="p">(</span><span class="n">status</span><span class="p">(</span><span class="n">n_samples_field</span><span class="p">),</span><span class="w"> </span><span class="n">n_samples</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">(</span><span class="s">&quot;for #processed samples&quot;</span><span class="p">)),</span><span class="w"> </span><span class="n">vunit_error</span><span class="p">);</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div></blockquote>
<p>Running the simulation again reveals the following log:</p>
<blockquote>
<div><div class="highlight" style="background: #002b36; color: #eee8d5;"><pre style="line-height: 125%; background: #002b36; color: #eee8d5;"><span style="color: #2aa198; ">178000 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">vunit_lib</span><span style="font_weight: bold; color: #2aa198; ">:</span><span style="font_weight: bold; color: #eee8d5; ">event_pkg</span>          -    <span style="font_weight: bold; color: #eee8d5; ">INFO</span> - Event vunit_lib:vunit_error activated while waiting on "wait until is_active(new_data_set);" (tb_event.vhd:417)
<span style="color: #2aa198; ">178000 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">check</span>                        -   <span style="font_weight: bold; color: #cb4b16; ">ERROR</span> - Equality check failed for #processed samples - Got 0000_0101 (5). Expected 10 (0000_1010). (tb_event.vhd:265)
</pre></div>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">dut_checker</span></code> isn’t stuck where we expected it to be. Instead it is waiting for the next data set which suggests
that all of the expected output data have been received before the max latency, and we should look for the bug
elsewhere. It turns out that the root cause of the issue is an error in the range definition of the <code class="docutils literal notranslate"><span class="pre">n_samples_field</span></code>.
The range is shifted one bit which causes the read value to be half of the actual value. The additional information
provided by the wait statements triggered by <code class="docutils literal notranslate"><span class="pre">vunit_error</span></code> can be very helpful in situations like these, as it can
confirm our initial suspicions or direct us towards another possible explanation.</p>
<p>You may have noticed that the wait statement triggered in this case wasn’t prepared with a call to the <code class="docutils literal notranslate"><span class="pre">log_active</span></code>
function. So, how was the log entry generated? What we did was to create a
<a class="reference internal" href="../py/vunit.html#vunit.ui.preprocessor.Preprocessor" title="vunit.ui.preprocessor.Preprocessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">VUnit</span> <span class="pre">preprocessor</span></code></a> to identify wait statements and then modified them to
include a call to <code class="docutils literal notranslate"><span class="pre">log_active</span></code>. This allowed us to automatically generate log entries for wait statements not prepared
to generate extra debug information. The design of such a preprocessor somewhat depends on the project setup but you can
use this example as a template for your own project.</p>
<blockquote>
<div><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">vunit.ui.preprocessor</span> <span class="kn">import</span> <span class="n">Preprocessor</span>


<span class="k">class</span> <span class="nc">WaitStatementPreprocessor</span><span class="p">(</span><span class="n">Preprocessor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A preprocessor is a class with a run method that transforms code. It is based on the Preprocessor class.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The order argument to the constructor controls the order in which preprocessors are applied.</span>
<span class="sd">        Lowest number first.&quot;&quot;&quot;</span>

        <span class="c1"># Call constructor of base class</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>

        <span class="c1"># Regular expression finding wait statements on the form</span>
        <span class="c1"># wait [on sensitivity_list] [until condition] [for timeout];</span>
        <span class="c1"># Any preceding text (prefix) is also picked-up. It will be examined later to exclude some special cases.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wait_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
            <span class="sa">r</span><span class="s2">&quot;(?P&lt;prefix&gt;^[^\r\n]*?)(?P&lt;wait&gt;wait)(\s+on\s+(?P&lt;sensitivity_list&gt;.*?))?(\s+until\s+(?P&lt;condition&gt;.*?))?(\s+for\s+(?P&lt;timeout&gt;.*?))?;&quot;</span><span class="p">,</span>
            <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">file_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The run method must take the code string and the file_name as arguments.&quot;&quot;&quot;</span>

        <span class="c1"># Only process testbenches</span>
        <span class="k">if</span> <span class="s2">&quot;runner_cfg&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">code</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">code</span>

        <span class="c1"># Find all wait statements and sort them in reverse order of appearance to simplify processing</span>
        <span class="n">wait_statements</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wait_re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">code</span><span class="p">))</span>
        <span class="n">wait_statements</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">wait_statement</span><span class="p">:</span> <span class="n">wait_statement</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">wait_statement</span> <span class="ow">in</span> <span class="n">wait_statements</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="n">wait_statement</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;prefix&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">prefix</span><span class="p">:</span>
                <span class="c1"># Ignore commented wait statements and wait-looking statements in strings (not foolproof)</span>
                <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;--&quot;</span> <span class="ow">in</span> <span class="n">prefix</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s1">&#39;&quot;&#39;</span> <span class="ow">in</span> <span class="n">prefix</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="c1"># Remove any preceding statements but keep labels</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>

            <span class="n">modified_wait_statement</span> <span class="o">=</span> <span class="s2">&quot;wait&quot;</span>

            <span class="c1"># If the wait statement has an explicit sensitivity list (on ...), then vunit_error must be added to that</span>
            <span class="n">sensitivity_list</span> <span class="o">=</span> <span class="n">wait_statement</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;sensitivity_list&quot;</span><span class="p">)</span>
            <span class="n">sensitivity_list_signals</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">sensitivity_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sensitivity_list_signals</span> <span class="o">=</span> <span class="p">[</span><span class="n">signal</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">signal</span> <span class="ow">in</span> <span class="n">sensitivity_list</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)]</span>
                <span class="n">new_sensitivity_list</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sensitivity_list_signals</span><span class="p">)</span><span class="si">}</span><span class="s2">, vunit_error&quot;</span>
                <span class="n">modified_wait_statement</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; on </span><span class="si">{</span><span class="n">new_sensitivity_list</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="c1"># Add log_active to an existing condition clause (until ...) or create one if not present</span>
            <span class="n">original_wait_statement</span> <span class="o">=</span> <span class="n">wait_statement</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="n">wait_statement</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s2">&quot;wait&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="n">wait_statement</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="p">:]</span>
            <span class="n">log_message</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;decorate(&quot;while waiting on &quot;&quot;</span><span class="si">{</span><span class="n">original_wait_statement</span><span class="si">}</span><span class="s1">&quot;&quot;&quot;)&#39;</span>
            <span class="c1"># The location preprocessor will not detect that the code in the message is quoted and it will modify</span>
            <span class="c1"># any function it targets. is_active_msg is such a function but by appending a non-printable character</span>
            <span class="c1"># to that function name we avoid this problem without altering the logged message</span>
            <span class="n">log_message</span> <span class="o">=</span> <span class="n">log_message</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;is_active_msg&quot;</span><span class="p">,</span> <span class="s1">&#39;is_active_msg&quot; &amp; NUL &amp; &quot;&#39;</span><span class="p">)</span>
            <span class="n">condition</span> <span class="o">=</span> <span class="n">wait_statement</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;condition&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">condition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># If there was a sensitivity list the VHDL event attribute of those signals must be in the</span>
                <span class="c1"># condition or the wait statement will remain blocked on those VHDL events (log_active always</span>
                <span class="c1"># returns false).</span>
                <span class="n">new_condition</span> <span class="o">=</span> <span class="s2">&quot; or &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">signal</span><span class="si">}</span><span class="s2">&#39;event&quot;</span> <span class="k">for</span> <span class="n">signal</span> <span class="ow">in</span> <span class="n">sensitivity_list_signals</span><span class="p">])</span>
                <span class="n">new_condition</span> <span class="o">=</span> <span class="n">new_condition</span> <span class="o">+</span> <span class="s2">&quot; or &quot;</span> <span class="k">if</span> <span class="n">new_condition</span> <span class="k">else</span> <span class="n">new_condition</span>
                <span class="n">new_condition</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;log_active(vunit_error, </span><span class="si">{</span><span class="n">log_message</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="k">elif</span> <span class="s2">&quot;vunit_error&quot;</span> <span class="ow">in</span> <span class="n">condition</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># Don&#39;t touch a wait statement already triggering on vunit_error</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># The condition_operator function turns the original condition to a boolean that can be ORed</span>
                <span class="c1"># with the boolean log_active function. Using the condition operator (??) doesn&#39;t work since it can&#39;t</span>
                <span class="c1"># be applied to a condition that was already a boolean</span>
                <span class="n">new_condition</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;condition_operator(</span><span class="si">{</span><span class="n">condition</span><span class="si">}</span><span class="s2">) or log_active(vunit_error, </span><span class="si">{</span><span class="n">log_message</span><span class="si">}</span><span class="s2">)&quot;</span>

            <span class="n">modified_wait_statement</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; until </span><span class="si">{</span><span class="n">new_condition</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="c1"># The time clause (for ...) is not modified</span>
            <span class="n">timeout</span> <span class="o">=</span> <span class="n">wait_statement</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s2">&quot;timeout&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">modified_wait_statement</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; for </span><span class="si">{</span><span class="n">timeout</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="n">modified_wait_statement</span> <span class="o">+=</span> <span class="s2">&quot;;&quot;</span>

            <span class="c1"># Replace original wait statement</span>
            <span class="n">code</span> <span class="o">=</span> <span class="n">code</span><span class="p">[:</span> <span class="n">wait_statement</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s2">&quot;wait&quot;</span><span class="p">)]</span> <span class="o">+</span> <span class="n">modified_wait_statement</span> <span class="o">+</span> <span class="n">code</span><span class="p">[</span><span class="n">wait_statement</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="n">code</span>
</pre></div>
</div></blockquote>
<p>The preprocessor is added to the project using the <a class="reference internal" href="../py/vunit.html#vunit.ui.VUnit.add_preprocessor" title="vunit.ui.VUnit.add_preprocessor"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_preprocessor()</span></code></a> method. By setting the
order number lower than that of the location preprocessor (which has a default value of 100), the <code class="docutils literal notranslate"><span class="pre">log_active</span></code>
function is inserted first, allowing the location preprocessor to accurately pinpoint the source of the statement.</p>
<div class="highlight"><pre><span></span><span class="n">vu</span> <span class="o">=</span> <span class="n">VUnit</span><span class="o">.</span><span class="n">from_argv</span><span class="p">()</span>
<span class="n">vu</span><span class="o">.</span><span class="n">enable_location_preprocessing</span><span class="p">()</span>  <span class="c1"># order = 100 if no other value is provided</span>
<span class="n">vu</span><span class="o">.</span><span class="n">add_preprocessor</span><span class="p">(</span><span class="n">WaitStatementPreprocessor</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="mi">99</span><span class="p">))</span>
</pre></div>
<div class="admonition-exercise admonition">
<p class="admonition-title">Exercise</p>
<p>Create a preprocessor that wraps check procedures in a <code class="docutils literal notranslate"><span class="pre">notify_if_fail</span></code> call such that all detected errors
triggers the <code class="docutils literal notranslate"><span class="pre">vunit_error</span></code> event.</p>
</div>
<p>In this example, we were fortunate in that the error occurred during a wait statement that was directly related to the
issue at hand, making it easy to locate the bug. However, this is not always the case. To fully understand the issue, it is often necessary to examine the internal signal state. One way to address this is to continuously log a large number of signals at every clock edge. However, this approach quickly leads to unwieldy and difficult-to-manage logs. A more effective solution is to</p>
<ol class="arabic simple">
<li><p>Continuously log a smaller, targeted set of interesting signals and events that can provide insights into what led
up to the error.</p></li>
<li><p>At the time of an error, log a much larger set of signals to obtain detailed information about the state of the
system.</p></li>
</ol>
<p>The larger set of signals is provided by one or several “core dump” processes that are triggered by <code class="docutils literal notranslate"><span class="pre">vunit_error</span></code>.
For example, in our code example, the DUT has a data processing pipeline and a control block that manages register reads
and writes. Both of these blocks have states that are interesting for debugging. A core dump of these states might look
like this:</p>
<div class="highlight"><pre><span></span><span class="c1">-- pragma translate_off</span><span class="w"></span>
<span class="n">core_dump</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">process</span><span class="w"></span>
<span class="w">  </span><span class="k">constant</span><span class="w"> </span><span class="n">logger</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">logger_t</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">get_logger</span><span class="p">(</span><span class="s">&quot;incrementer:core_dump&quot;</span><span class="p">);</span><span class="w"></span>
<span class="k">begin</span><span class="w"></span>
<span class="w">  </span><span class="k">wait</span><span class="w"> </span><span class="k">until</span><span class="w"> </span><span class="n">is_active</span><span class="p">(</span><span class="n">vunit_error</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="n">info</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Control state is &quot;</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">control_state_t</span><span class="na">&#39;image</span><span class="p">(</span><span class="n">control_state</span><span class="p">));</span><span class="w"></span>
<span class="w">  </span><span class="n">info</span><span class="p">(</span><span class="n">logger</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Data processing state is &quot;</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">data_processing_state_t</span><span class="na">&#39;image</span><span class="p">(</span><span class="n">data_processing_state</span><span class="p">));</span><span class="w"></span>
<span class="k">end</span><span class="w"> </span><span class="k">process</span><span class="p">;</span><span class="w"></span>
<span class="c1">-- pragma translate_on</span><span class="w"></span>
</pre></div>
<p>In this case the core dump process was encapsulated in the RTL code and pragmas were used to exclude it from synthesis.
An alternative, if supported by your simulator, is to add the process to the testbench and then use external names to
access the DUT-internal state signals.</p>
<p>The updated log now shows that both blocks are idle when the error occurs. This also confirms that there is no latency issue, as there are no pending data being processed.</p>
<div class="highlight" style="background: #002b36; color: #eee8d5;"><pre style="line-height: 125%; background: #002b36; color: #eee8d5;"><span style="color: #2aa198; ">178000 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">incrementer</span><span style="font_weight: bold; color: #2aa198; ">:</span><span style="font_weight: bold; color: #eee8d5; ">core_dump</span>        -    <span style="font_weight: bold; color: #eee8d5; ">INFO</span> - Control state is idle (incrementer.vhd:180)
<span style="color: #2aa198; ">178000 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">incrementer</span><span style="font_weight: bold; color: #2aa198; ">:</span><span style="font_weight: bold; color: #eee8d5; ">core_dump</span>        -    <span style="font_weight: bold; color: #eee8d5; ">INFO</span> - Data processing state is idle (incrementer.vhd:181)
<span style="color: #2aa198; ">178000 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">vunit_lib</span><span style="font_weight: bold; color: #2aa198; ">:</span><span style="font_weight: bold; color: #eee8d5; ">event_pkg</span>          -    <span style="font_weight: bold; color: #eee8d5; ">INFO</span> - Event vunit_lib:vunit_error activated while waiting on "wait until is_active(new_data_set);" (tb_event.vhd:417)
<span style="color: #2aa198; ">178000 ps</span> - <span style="font_weight: bold; color: #eee8d5; ">check</span>                        -   <span style="font_weight: bold; color: #cb4b16; ">ERROR</span> - Equality check failed for #processed samples - Got 0000_0101 (5). Expected 10 (0000_1010). (tb_event.vhd:265)
</pre></div>
</section>
<section id="close-but-no-cigar">
<h2>Close, but No Cigar<a class="headerlink" href="#close-but-no-cigar" title="Link to this heading">¶</a></h2>
<p>So far VUnit events helped us synchronize processes, perform core dumps and reveal blocking wait statements to aid
debugging, and prevent premature termination of a simulation. However, using events to create a barrier for premature
terminations is a solution with several problems:</p>
<ol class="arabic simple">
<li><p>It doesn’t scale well. For every process that has to complete we need a new event.</p></li>
<li><p>There is a race condition. If a process completes before the test runner process starts waiting for the completion
event, the test runner process will block and never call <code class="docutils literal notranslate"><span class="pre">test_runner_cleanup</span></code> to end the simulation.</p></li>
<li><p>If we fail to recognize that there is a completion event for a process, or simply forget to add it, we still face
the risk of a premature simulation termination.</p></li>
</ol>
<p>A better solution would be one that allows any process to prevent <code class="docutils literal notranslate"><span class="pre">test_runner_cleanup</span></code> from ending the simulation
before that process has completed. There is only one <code class="docutils literal notranslate"><span class="pre">test_runner_cleanup</span></code> call so it scales well and forgetting to
add it will cause the testbench to fail. The event race condition is also removed since a process completing before the
test runner process reaches <code class="docutils literal notranslate"><span class="pre">test_runner_cleanup</span></code> will have stopped preventing simulation termination.</p>
<p>Fortunately VUnit provides such a solution. It’s called VUnit phases and it will be the topic for the next blog.</p>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="2022_09_19_vunit_user_conference.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">VUnit User Conference</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="2023_04_01_vunit_phases.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">VUnit Phases</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2014-2024, Lars Asplund
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              <a class="muted-link fa-solid fa-brands fa-twitter" href="https://twitter.com/VUnitFramework" aria-label="Twitter @VUnitFramework"></a>
              <a class="muted-link fa-solid fa-brands fa-gitter" href="https://gitter.im/VUnit/vunit" aria-label="Gitter VUnit/vunit"></a>
              <a class="muted-link fa-solid fa-brands fa-github" href="https://github.com/VUnit/vunit" aria-label="GitHub VUnit/vunit"></a>
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">VUnit Events</a><ul>
<li><a class="reference internal" href="#what-you-will-learn">What You Will Learn</a></li>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#two-types-of-vunit-events">Two Types of VUnit Events</a></li>
<li><a class="reference internal" href="#user-defined-events">User-Defined Events</a></li>
<li><a class="reference internal" href="#vunit-provided-events">VUnit-Provided Events</a></li>
<li><a class="reference internal" href="#close-but-no-cigar">Close, but No Cigar</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=46bd48cc"></script>
    </body>
</html>